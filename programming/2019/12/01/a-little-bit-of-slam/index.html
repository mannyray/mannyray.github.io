<!DOCTYPE html>
<html>

  <head>
  
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>A little bit of SLAM</title>
  <meta name="description" content="A little bit of SLAM">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://szonov.com/programming/2019/12/01/a-little-bit-of-slam/">
  <link rel="alternate" type="application/rss+xml" title="Stan Zonov" href="https://szonov.com/feed.xml" />
</head>


  <body>
	
    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Stan Zonov</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
	<a class="page-link" href=""></a>
        
		
			<a class="page-link" href="/about/">About</a>
        
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
            <a class="page-link" href="/consulting/">Consulting</a>
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			<a class="page-link" href="/photos/">Photos</a>
		
        
	<a class="page-link" href="/">Blog</a>
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
 	 
    <h1 class="post-title">A little bit of SLAM</h1>
    <p class="post-meta">Dec 1, 2019</p>
  </header>

  <article class="post-content">
    <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<body>
<p style="height:0px;width:0px"></p>
        <link rel="stylesheet" href="/css/content_font/content_font.css">

<style>
    .toc_and_content_table{
        border: none;
    }
    .toc {
        width: 25%;
        vertical-align:top;
        border: none;
        padding:0px;
        border: none;
    }
    .content {
        padding: 10px;
        border: none;
    }
    .scrollable{
        height: auto;        /* Allow it to grow based on content */
        max-height: 100vh;
        overflow-y: auto;
    }
    .sticky-top {
        position: -webkit-sticky;
        position: sticky;
        top: 0;
        background: #fff; /* Background for the sticky menu */
    }
    #menu {
        list-style-type: none; /* Remove bullets */
        padding: 0; /* Remove padding */
        margin: 0; /* Remove margin */
    }
    #menu li {
        margin: 5px 0; /* Space between bars */
        position: relative
    }
    #menu a {
        display: block; /* Make the link a block element */
        padding: 2px; /* Space inside the bars */
        background: #f0f0f0; /* Light gray background for bars */
        text-decoration: none; /* Remove underline */
        color: #333; /* Text color */
        border-radius: 4px; /* Rounded corners */
        transition: background 0.3s; /* Smooth background transition */
    }
    #menu a:hover {
        background: #e0e0e0; /* Darker gray on hover */
    }
    .active {
        font-weight: bold;
        color: blue; /* Change the color for highlighting */
    }
    .active::after {
        content: '';
        position: absolute;
        top: 0;
        border-radius: 4px;
        left: 0;
        height: 100%;
        width: 100%;
        background: #007bff; /* Active background color */
        transform: scaleX(0); /* Start with no width */
        transform-origin: left; /* Scale from the left */
        animation: load 0.5s forwards; /* Loading animation */
        background: rgba(0, 123, 255, 0.5); /* Semi-transparent active background color */
    }
    @keyframes load {
        0% {
            transform: scaleX(0); /* Start with no width */
        }
        70% {
            transform:  scaleX(1); /* Scale to full width */
        }
        85% {
            transform: scaleX(0.95); /* Bounce effect */
        }
        100% {
            transform: scaleX(1); /* Return to full width */
        }
    }
    .section {
        border: 0;
        height: 100%;
        margin: 0;
        padding: 0;
        width: 100%;
    }
    
    .desktop-only {
        display: none;
    }
    /* Show mobile paragraph on mobile devices */
    .mobile-only {
        display: block;
    }
    /* Media query for non-mobile devices */
    @media (min-width: 768px) {
        .desktop-only {
            display: block;
        }
        .mobile-only {
            display: none;
        }
    }
    
    /* mobile version*/
    .popup-button {
        font-size: 24px;
        position: fixed;
        top: 50%;
        right: 0;
        transform: translateY(-50%); /* Center vertically */
        padding: 10px 20px;
        background-color: #f0f0f0;
        border-radius: 5px;
        cursor: pointer;
        opacity: 0; /* Start invisible */
        visibility: hidden; /* Initially hidden */
        transition: opacity 0.5s ease, visibility 0.5s ease; /* Fade effect */
    }
    .popup-button.show {
        opacity: 1; /* Fully visible */
        visibility: visible; /* Make it visible */
    }
    .target-section {
        background-color: #f0f0f0;
    }
    .sidebar {
        position: fixed;
        right: 0; /* Align sidebar directly to the right edge */
        width: 200px; /* Set the width of the sidebar */
        max-height: 80vh; /* Limit height for scrolling */
        background: #fff; /* Background for the sidebar */
        padding: 10px; /* Padding inside the sidebar */
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); /* Subtle shadow for depth */
        z-index: 1000; /* Ensure it appears above other elements */
        transform: translate(0, -50%) scale(0); /* Start hidden and minimized */
        transform-origin: right center; /* Scale from the right */
        transition: transform 0.3s ease, visibility 0.5s ease; /* Smooth transition */
        visibility: hidden; /* Initially hidden */
        border: 1px solid #ccc; /* Add a border */
        border-radius: 8px; /* Slightly rounded corners */
    }
    .sidebar.show {
        transform: translate(0, -50%) scale(1); /* Show the sidebar */
        visibility: visible; /* Make it visible */
    }
    .sidebar h3 {
        margin: 0; /* Remove default margin */
        padding: 0; /* Remove default padding */
        height: 40px; /* Set height for better alignment */
    }
    .mobile-scrollable{
        height: auto;        /* Allow it to grow based on content */
        max-height: 70vh;
        overflow-y: auto;
    }
</style>
<h1 id="a-little-bit-of-slam">A little bit of SLAM</h1>

<p>Let’s work with SLAM. A great series of papers on the topic are here:</p>

<ul>
  <li>Simultaneous Localisation and Mapping (SLAM):Part I The Essential Algorithms - Tim Bailey and Hugh Durrant-Whyte</li>
  <li>Simultaneous Localisation and Mapping (SLAM):Part II State of the Art - Tim Bailey and Hugh Durrant-Whyte</li>
</ul>

<p>Simultaneous Localization and Mapping (SLAM) “problem asks if it is possible for a mobile robot to be placed at an unknown location in an unknown environment and for the robot to incrementally build a consistent map of this environment while simultaneously determining its location within this map.”</p>

<p>Let’s get our hands dirty right away and formulate a system to work with. We will be working with a 2D system where our robot along with landmarks will be treated as (x,y) points. To keep things simple, our robot will be moving on a predefined path such that it does not collide with the landmarks to avoid adding additional logic to the robot. We will be working with Octave.</p>

<p>We first define the robot starting conditions as well as the landmarks:</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="nb">clear</span> <span class="nb">all</span><span class="p">;</span>
<span class="nb">close</span> <span class="nb">all</span><span class="p">;</span>
<span class="c1">%set the seed - one of the few commands used here that is _unique_ to Octave</span>
<span class="nb">randn</span><span class="p">(</span><span class="s2">"seed"</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

<span class="c1">%robot starting initial conditions</span>
<span class="n">robotX</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="n">robotY</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="n">spreadFromCenter</span><span class="o">=</span><span class="mi">40</span><span class="p">;</span>
<span class="n">xMin</span> <span class="o">=</span> <span class="mi">100</span><span class="o">-</span><span class="n">spreadFromCenter</span><span class="p">;</span>
<span class="n">xMax</span><span class="o">=</span><span class="mi">100</span><span class="o">+</span><span class="n">spreadFromCenter</span><span class="p">;</span>
<span class="n">yMin</span><span class="o">=</span><span class="mi">100</span><span class="o">-</span><span class="n">spreadFromCenter</span><span class="p">;</span>
<span class="n">yMax</span><span class="o">=</span><span class="mi">100</span><span class="o">+</span><span class="n">spreadFromCenter</span><span class="p">;</span>

<span class="c1">%landmarks on the map</span>
<span class="n">xCoords</span> <span class="o">=</span> <span class="p">[</span><span class="mi">80</span><span class="p">,</span><span class="mi">90</span><span class="p">,</span><span class="mi">110</span><span class="p">,</span><span class="mi">120</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">90</span><span class="p">,</span><span class="mi">110</span><span class="p">,</span><span class="mi">120</span><span class="p">];</span>
<span class="n">yCoords</span> <span class="o">=</span> <span class="p">[</span><span class="mi">80</span><span class="p">,</span><span class="mi">90</span><span class="p">,</span><span class="mi">110</span><span class="p">,</span><span class="mi">120</span><span class="p">,</span><span class="mi">90</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">120</span><span class="p">,</span><span class="mi">130</span><span class="p">];</span>
<span class="n">pointNumber</span> <span class="o">=</span> <span class="nb">length</span><span class="p">(</span><span class="n">xCoords</span><span class="p">);</span></code></pre></figure>

<p>Let’s setup the robot’s movement, before worrying about the landmarks. Assume the robot is on a rail road - the y coordinate is unaffected. The robot will be moving at a constant speed with white noise affecting the motion. The following image will describe the situation:</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="n">h</span> <span class="o">=</span> <span class="nb">figure</span><span class="p">;</span>
<span class="nb">hold</span> <span class="n">on</span><span class="p">;</span>
<span class="nb">scatter</span><span class="p">(</span><span class="n">xCoords</span><span class="p">,</span><span class="n">yCoords</span><span class="p">,</span><span class="s1">'*b'</span><span class="p">);</span>
<span class="nb">scatter</span><span class="p">(</span><span class="n">robotX</span><span class="p">,</span><span class="n">robotY</span><span class="p">,</span><span class="s1">'or'</span><span class="p">,</span><span class="s1">'filled'</span><span class="p">);</span>
<span class="nb">plot</span><span class="p">([</span><span class="n">robotX</span><span class="p">,</span><span class="n">robotX</span><span class="p">],[</span><span class="n">robotY</span><span class="p">,</span><span class="mi">200</span><span class="p">],</span><span class="s1">'k--'</span><span class="p">)</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'Landmarks'</span><span class="p">,</span><span class="s1">'Robot'</span><span class="p">,</span><span class="s1">'Robot path'</span><span class="p">);</span>
<span class="nb">xlim</span><span class="p">([</span><span class="mi">100</span><span class="o">-</span><span class="n">spreadFromCenter</span><span class="p">,</span><span class="mi">100</span><span class="o">+</span><span class="n">spreadFromCenter</span><span class="p">]);</span>
<span class="nb">ylim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">200</span><span class="p">]);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'x'</span><span class="p">);</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'y'</span><span class="p">);</span>
<span class="nb">axis</span><span class="p">(</span><span class="s2">"equal"</span><span class="p">)</span></code></pre></figure>

<p><img src="https://szonov.com/assets/SLAM/setup1.png" alt=""></p>

<p>Now lets generate an actual instance of the robot’s motion.</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="c1">%total timesteps of robot</span>
<span class="n">timesteps</span> <span class="o">=</span> <span class="mi">400</span><span class="p">;</span>
<span class="c1">%speed of the robot (distance covered by timestep)</span>
<span class="n">speed</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>
<span class="c1">%function representing the movement - first entry is x coordinate, second y.</span>
<span class="n">next_func</span><span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span><span class="nb">time</span><span class="p">)</span> <span class="n">coord</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="n">speed</span><span class="p">];</span> 
<span class="c1">%process noise - a little noise is added to model in order to be able to do Cholesky decomposition</span>
<span class="n">processNoiseCovariance</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.00000000001</span><span class="p">,</span><span class="mi">0</span><span class="p">;</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.2</span><span class="p">];</span>
<span class="c1">%store the results</span>
<span class="n">movementCoords</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">timesteps</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="c1">%initial conditions</span>
<span class="n">movementCoords</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">robotX</span><span class="p">;</span>
<span class="n">movementCoords</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">robotY</span><span class="p">;</span>
<span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">timesteps</span>
	<span class="n">movementCoords</span><span class="p">(:,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">next_func</span><span class="p">(</span><span class="n">movementCoords</span><span class="p">(:,</span><span class="n">i</span><span class="p">),</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="nb">chol</span><span class="p">(</span><span class="n">processNoiseCovariance</span><span class="p">)</span><span class="o">'*</span><span class="nb">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span> 
<span class="k">end</span></code></pre></figure>

<p>Now, let’s plot the y-coordinate evolution:</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="n">h</span> <span class="o">=</span> <span class="nb">figure</span><span class="p">;</span>
<span class="nb">plot</span><span class="p">(</span><span class="mi">1</span><span class="p">:(</span><span class="n">timesteps</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">movementCoords</span><span class="p">(</span><span class="mi">2</span><span class="p">,:))</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'Y'</span><span class="p">)</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'Time'</span><span class="p">)</span>
<span class="nb">axis</span><span class="p">(</span><span class="s2">"equal"</span><span class="p">)</span></code></pre></figure>

<p><img src="https://szonov.com/assets/SLAM/setup2.png" alt=""></p>

<p>We will set it so that the robot has a maximum measurement radius. Read <a href="https://www.cs.utexas.edu/~kuipers/slides/L17-FastSLAM.pdf">this</a> for more info on the measurement function used. We will generate noisy measurements of the landmarks based on the position of the landmark.</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="n">measurementRadius</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span>
<span class="n">angles</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="nb">ones</span><span class="p">(</span><span class="n">timesteps</span><span class="p">,</span><span class="n">pointNumber</span><span class="p">);</span>
<span class="nb">distances</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="nb">ones</span><span class="p">(</span><span class="n">timesteps</span><span class="p">,</span><span class="n">pointNumber</span><span class="p">);</span> 
<span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">timesteps</span>
	<span class="n">curRobotX</span> <span class="o">=</span> <span class="n">movementCoords</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
	<span class="n">curRobotY</span> <span class="o">=</span> <span class="n">movementCoords</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>	

	<span class="k">for</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">pointNumber</span>
		<span class="n">distance</span> <span class="o">=</span> <span class="nb">norm</span><span class="p">([</span><span class="n">curRobotX</span><span class="p">;</span><span class="n">curRobotY</span><span class="p">]</span> <span class="o">-</span> <span class="p">[</span><span class="n">xCoords</span><span class="p">(</span><span class="n">j</span><span class="p">);</span> <span class="n">yCoords</span><span class="p">(</span><span class="n">j</span><span class="p">)]);</span> 
		<span class="k">if</span> <span class="n">distance</span> <span class="o">&lt;=</span> <span class="n">measurementRadius</span>
			<span class="nb">distances</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">distance</span><span class="p">;</span>  
			<span class="n">angles</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="nb">atan2</span><span class="p">(</span> <span class="n">yCoords</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">-</span> <span class="n">curRobotY</span> <span class="p">,</span> <span class="n">xCoords</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">-</span> <span class="n">curRobotX</span><span class="p">);</span>
		<span class="k">end</span>	
	<span class="k">end</span>
<span class="k">end</span>
<span class="c1">%add noise</span>
<span class="n">angleCovariance</span> <span class="o">=</span> <span class="mf">0.004</span><span class="p">;</span>
<span class="n">distanceCovariance</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">;</span>
<span class="n">anglesNoisy</span> <span class="o">=</span> <span class="n">angles</span> <span class="o">+</span> <span class="nb">randn</span><span class="p">(</span><span class="nb">size</span><span class="p">(</span><span class="n">angles</span><span class="p">))</span><span class="o">.*</span><span class="nb">sqrt</span><span class="p">(</span><span class="n">angleCovariance</span><span class="p">);</span>
<span class="n">distancesNoisy</span> <span class="o">=</span> <span class="nb">distances</span> <span class="o">+</span> <span class="nb">randn</span><span class="p">(</span><span class="nb">size</span><span class="p">(</span><span class="nb">distances</span><span class="p">))</span><span class="o">.*</span><span class="nb">sqrt</span><span class="p">(</span><span class="n">distanceCovariance</span><span class="p">);</span></code></pre></figure>

<p>Now that we have measurements we are ready to code up our robot exploring the environment. We will assume that the robot does not know now anything about the landmarks:</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="n">landMarkDiscoveredCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>We will set the following variable to be used in identifying if a measurement is associated with a new landmark. If we already are aware that there are <code class="language-plaintext highlighter-rouge">n</code> landmarks then we can compare the current measurement’s distance from the estimated location of the other <code class="language-plaintext highlighter-rouge">n</code> landmarks to decide if the new measurement is far enough to belong to a new landmark.</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="n">minMahalanobisDistance</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span></code></pre></figure>

<p>The rest of the script is given below. In it the robot moves forward and once it is at the appropriate measurement range, it ‘receives’ measurements from the landmark (the distance and angle with respect to the robot). The robot then decides if it is associated with a new landmark or not. If yes, then it is registered and a new estimate and associated covariance is set up for the landmark’s Kalman filter. Otherwise, the Kalman filter (specifically the update phase) is used to update the estimate (that is closest to the measured landmark).</p>

<figure class="highlight"><pre><code class="language-matlab" data-lang="matlab"><span class="c1">%estimate location of discovered landmarks</span>
<span class="n">landMarkMeans</span> <span class="o">=</span> <span class="p">{};</span>
<span class="c1">%estimate of angle and distance from robot to landmark</span>
<span class="n">landMarkAngleDistances</span> <span class="o">=</span> <span class="p">{};</span>
<span class="c1">%associated covariance with landMarkAngleDIstances</span>
<span class="n">landMarkCovariances</span> <span class="o">=</span> <span class="p">{};</span>
<span class="c1">%record of measurements </span>
<span class="n">landMarkMeasurements</span> <span class="o">=</span> <span class="p">{};</span>
<span class="c1">%record of all estimates</span>
<span class="n">landMarkEstimates</span> <span class="o">=</span> <span class="p">{};</span>


<span class="c1">%creating animation to store images </span>
<span class="c1">%can be a little slow in octave - remove saveas part </span>
<span class="c1">%to just view it</span>
<span class="n">h</span> <span class="o">=</span> <span class="nb">figure</span><span class="p">;</span>
<span class="nb">hold</span> <span class="n">on</span><span class="p">;</span>
<span class="nb">axis</span><span class="p">(</span><span class="s1">'equal'</span><span class="p">);</span>
<span class="nb">xlim</span><span class="p">([</span><span class="mi">100</span><span class="o">-</span><span class="n">spreadFromCenter</span><span class="p">,</span><span class="mi">100</span><span class="o">+</span><span class="n">spreadFromCenter</span><span class="p">]);</span>
<span class="nb">ylim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">200</span><span class="p">]);</span>

<span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">timesteps</span>
	<span class="c1">%current position of robot - here it is known </span>
	<span class="c1">%next extension would let the position be unknown </span>
	<span class="c1">%and the predict phase of the Kalman filter to deal with it</span>
	<span class="n">curRobotX</span> <span class="o">=</span> <span class="n">movementCoords</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
	<span class="n">curRobotY</span> <span class="o">=</span> <span class="n">movementCoords</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>	
	
	<span class="c1">%there are a total pointNumber landmarks - which our robot has no idea.</span>
	<span class="c1">%However, we still have to cycle through all the landmarks at a given timestep</span>
	<span class="c1">%in order to simulate an incoming measurement based on measurementRadius value.</span>
	<span class="k">for</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">pointNumber</span>
		<span class="k">if</span> <span class="nb">distances</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">~=</span> <span class="o">-</span><span class="mi">1</span><span class="c1">%-1 flag used to signify that landmark is not in range</span>
			<span class="c1">%landmark in measurementRadius range</span>
			<span class="c1">%convert the measured angle and distance to an X and Y position</span>
			<span class="n">landmarkX</span> <span class="o">=</span> <span class="n">curRobotX</span> <span class="o">+</span> <span class="n">distancesNoisy</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="nb">cos</span><span class="p">(</span><span class="n">anglesNoisy</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">));</span> 
			<span class="n">landmarkY</span> <span class="o">=</span> <span class="n">curRobotY</span> <span class="o">+</span> <span class="n">distancesNoisy</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="nb">sin</span><span class="p">(</span><span class="n">anglesNoisy</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">));</span>

			<span class="c1">%variables to figure if landmark is new and if not then to </span>
			<span class="c1">%which recorded one does it associate with</span>
			<span class="n">landMarkIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">isNew</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			
			<span class="c1">%compute distance between measured landmark and all other estimates</span>
			<span class="n">minIndex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">minVal</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> 
			<span class="k">for</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">landMarkDiscoveredCount</span>
				<span class="n">mahalanobisDistance</span> <span class="o">=</span> <span class="nb">sqrt</span><span class="p">(</span> <span class="p">([</span><span class="n">landmarkX</span><span class="p">;</span><span class="n">landmarkY</span><span class="p">]</span> <span class="o">-</span> <span class="n">landMarkMeans</span><span class="p">{</span><span class="n">k</span><span class="p">})</span><span class="o">'</span>
					<span class="o">*</span><span class="p">([</span><span class="n">landmarkX</span><span class="p">;</span><span class="n">landmarkY</span><span class="p">]</span> <span class="o">-</span> <span class="n">landMarkMeans</span><span class="p">{</span><span class="n">k</span><span class="p">}));</span>
				<span class="k">if</span> <span class="n">minVal</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
					<span class="n">minVal</span> <span class="o">=</span> <span class="n">mahalanobisDistance</span><span class="p">;</span>
				<span class="k">elseif</span> <span class="n">minVal</span> <span class="o">&gt;</span> <span class="n">mahalanobisDistance</span>
					<span class="n">minVal</span> <span class="o">=</span> <span class="n">mahalanobisDistance</span><span class="p">;</span>
					<span class="n">minIndex</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
				<span class="k">end</span>
			<span class="k">end</span>
	
			
			<span class="k">if</span> <span class="n">minVal</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">minVal</span> <span class="o">&gt;</span> <span class="n">minMahalanobisDistance</span>
				<span class="c1">%-1 for first index</span>
				<span class="c1">%minVal &gt; ... means that it is far away from all previous measurements</span>
				<span class="n">isNew</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="n">landMarkDiscoveredCount</span> <span class="o">=</span> <span class="n">landMarkDiscoveredCount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">landMarkIndex</span> <span class="o">=</span> <span class="n">landMarkDiscoveredCount</span><span class="p">;</span> 
			<span class="k">else</span>
				<span class="c1">%measurement is associated with estimate that already exists </span>
				<span class="n">landMarkIndex</span> <span class="o">=</span> <span class="n">minIndex</span><span class="p">;</span>
			<span class="k">end</span>

			<span class="k">if</span> <span class="n">isNew</span> <span class="o">~=</span> <span class="nb">true</span>
				<span class="c1">%run Kalman filter's update phase </span>
				
				<span class="c1">%to define current estimate we need to compute the angle and distance keeping </span>
				<span class="c1">%in mind that the robot has moved since we computed the estimate last (we are updating</span>
				<span class="c1">%the estimate before running the update phase) </span>
				<span class="n">previous_position</span> <span class="o">=</span> <span class="n">landMarkMeans</span><span class="p">{</span><span class="n">landMarkIndex</span><span class="p">};</span>
				<span class="n">C_measurement</span> <span class="o">=</span> <span class="p">[</span><span class="nb">norm</span><span class="p">([</span><span class="n">curRobotX</span><span class="p">;</span><span class="n">curRobotY</span><span class="p">]</span> <span class="o">-</span> <span class="p">[</span><span class="n">previous_position</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="n">previous_position</span><span class="p">(</span><span class="mi">2</span><span class="p">)]);</span>
					<span class="nb">atan2</span><span class="p">(</span><span class="n">previous_position</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">curRobotY</span><span class="p">,</span><span class="n">previous_position</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">curRobotX</span><span class="p">)];</span>
				<span class="c1">%our update phase deals in [distance;angle] format</span>
				<span class="c1">%which is converted in the previous calculation meaning</span>
				<span class="c1">%that we can set jacobian to the identity matrix</span>
				<span class="n">C_jacobian</span> <span class="o">=</span> <span class="nb">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
				

				<span class="c1">%run the update phase</span>
				<span class="p">[</span><span class="n">estimate_next</span><span class="p">,</span> <span class="n">covariance_sqrt</span><span class="p">]</span> <span class="o">=</span> <span class="n">ddekf_update_phase</span><span class="p">(</span><span class="k">...</span>
					<span class="nb">chol</span><span class="p">([</span><span class="mi">50</span><span class="o">*</span><span class="n">distanceCovariance</span><span class="p">,</span><span class="mi">0</span><span class="p">;</span><span class="mi">0</span><span class="p">,</span><span class="n">angleCovariance</span><span class="p">])</span><span class="o">'</span><span class="p">,</span><span class="k">...</span>
					<span class="nb">chol</span><span class="p">(</span><span class="n">landMarkCovariances</span><span class="p">{</span><span class="n">landMarkIndex</span><span class="p">})</span><span class="o">'</span><span class="p">,</span><span class="k">...</span>
					<span class="n">C_jacobian</span><span class="p">,</span><span class="n">C_measurement</span><span class="p">,</span><span class="n">C_measurement</span><span class="p">,</span><span class="k">...</span>
					<span class="p">[</span><span class="n">distancesNoisy</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">);</span><span class="n">anglesNoisy</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]);</span>
					
				<span class="c1">%store computed results</span>
				<span class="n">landMarkAngleDistances</span><span class="p">{</span><span class="n">landMarkIndex</span><span class="p">}</span> <span class="o">=</span> <span class="n">estimate_next</span><span class="p">;</span>
				<span class="n">landMarkCovariances</span><span class="p">{</span><span class="n">landMarkIndex</span><span class="p">}</span> <span class="o">=</span> <span class="n">covariance_sqrt</span><span class="o">*</span><span class="n">covariance_sqrt</span><span class="o">'</span><span class="p">;</span>
				<span class="n">landMarkMeans</span><span class="p">{</span><span class="n">landMarkIndex</span><span class="p">}</span> <span class="o">=</span> <span class="p">[</span><span class="n">curRobotX</span> <span class="o">+</span> <span class="n">estimate_next</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="nb">cos</span><span class="p">(</span><span class="n">estimate_next</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span><span class="k">...</span>
					<span class="n">curRobotY</span> <span class="o">+</span> <span class="n">estimate_next</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="nb">sin</span><span class="p">(</span><span class="n">estimate_next</span><span class="p">(</span><span class="mi">2</span><span class="p">))];</span>
				<span class="n">landMarkMeasurements</span><span class="p">{</span><span class="n">landMarkIndex</span><span class="p">}(</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="k">end</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="n">landmarkX</span><span class="p">;</span><span class="n">landmarkY</span><span class="p">];</span>
				<span class="n">landMarkEstimates</span><span class="p">{</span><span class="n">landMarkIndex</span><span class="p">}(</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="k">end</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="n">landMarkMeans</span><span class="p">{</span><span class="n">landMarkIndex</span><span class="p">}];</span>
			<span class="k">else</span>
				<span class="c1">%in case landmark is new, then record results and intialise estimate and covariance </span>
				<span class="n">landMarkMeans</span><span class="p">{</span><span class="n">landMarkIndex</span><span class="p">}</span> <span class="o">=</span> <span class="p">[</span><span class="n">landmarkX</span><span class="p">;</span><span class="n">landmarkY</span><span class="p">];</span>
				<span class="n">landMarkAngleDistances</span><span class="p">{</span><span class="n">landMarkIndex</span><span class="p">}</span> <span class="o">=</span> <span class="p">[</span><span class="n">distancesNoisy</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">);</span><span class="n">anglesNoisy</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)];</span> 
				<span class="n">landMarkCovariances</span><span class="p">{</span><span class="n">landMarkIndex</span><span class="p">}</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">distanceCovariance</span><span class="p">,</span><span class="mi">0</span><span class="p">;</span><span class="mi">0</span><span class="p">,</span><span class="n">angleCovariance</span><span class="o">*</span><span class="mi">100</span><span class="p">];</span>
				<span class="n">landMarkIndex</span> <span class="o">=</span> <span class="n">landMarkDiscoveredCount</span><span class="p">;</span>
				<span class="n">landMarkMeasurements</span><span class="p">{</span><span class="n">landMarkIndex</span><span class="p">}</span> <span class="o">=</span>  <span class="p">[</span><span class="n">landmarkX</span><span class="p">;</span><span class="n">landmarkY</span><span class="p">];</span>
				<span class="n">landMarkEstimates</span><span class="p">{</span><span class="n">landMarkIndex</span><span class="p">}</span> <span class="o">=</span> <span class="p">[</span><span class="n">landMarkMeans</span><span class="p">{</span><span class="n">landMarkIndex</span><span class="p">}];</span>	
			<span class="k">end</span>
		<span class="k">end</span>
	<span class="k">end</span>
	<span class="c1">%plot results</span>
	<span class="k">for</span> <span class="n">jj</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">landMarkDiscoveredCount</span>
		<span class="k">for</span> <span class="n">kk</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="nb">length</span><span class="p">(</span><span class="n">landMarkMeasurements</span><span class="p">)</span>
			<span class="n">ttmp</span> <span class="o">=</span> <span class="n">landMarkMeasurements</span><span class="p">{</span><span class="n">kk</span><span class="p">};</span>
			<span class="nb">scatter</span><span class="p">(</span><span class="n">ttmp</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="k">end</span><span class="p">),</span><span class="n">ttmp</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="k">end</span><span class="p">),</span><span class="s1">'r'</span><span class="p">,</span><span class="s1">'.'</span><span class="p">)</span>
		<span class="k">end</span>
	<span class="k">end</span>
	<span class="c1">%scatter(xCoords,yCoords,'b','*'); %actual location of the landmarks</span>
	<span class="n">f1</span> <span class="o">=</span> <span class="n">drawCircle</span><span class="p">(</span><span class="n">curRobotX</span><span class="p">,</span><span class="n">curRobotY</span><span class="p">,</span><span class="n">measurementRadius</span><span class="p">,</span><span class="s1">'g'</span><span class="p">);</span>
	<span class="n">f2</span> <span class="o">=</span> <span class="nb">scatter</span><span class="p">(</span><span class="n">curRobotX</span><span class="p">,</span><span class="n">curRobotY</span><span class="p">,</span><span class="s1">'r'</span><span class="p">,</span><span class="s1">'filled'</span><span class="p">);</span>
	<span class="n">f3</span> <span class="o">=</span> <span class="nb">plot</span><span class="p">([</span><span class="n">curRobotX</span><span class="p">,</span><span class="n">curRobotX</span><span class="p">],[</span><span class="n">curRobotY</span><span class="p">,</span><span class="mi">200</span><span class="p">],</span><span class="s1">'k--'</span><span class="p">);</span>
	
	<span class="n">tmpPlot</span> <span class="o">=</span> <span class="p">[];</span>
	<span class="k">for</span> <span class="n">jj</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">landMarkDiscoveredCount</span>
		<span class="n">ttmp</span> <span class="o">=</span> <span class="n">landMarkMeans</span><span class="p">{</span><span class="n">jj</span><span class="p">};</span>
		<span class="n">tmpPlot</span> <span class="o">=</span> <span class="p">[</span><span class="n">tmpPlot</span><span class="p">,</span><span class="nb">scatter</span><span class="p">(</span><span class="n">ttmp</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">ttmp</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="s2">"k"</span><span class="p">)];</span>
	<span class="k">end</span>
	<span class="c1">%%%REMOVE saveas line for speedup</span>
	<span class="nb">saveas</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="nb">strcat</span><span class="p">(</span><span class="s1">'output'</span><span class="p">,</span><span class="nb">num2str</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="s1">'%04d'</span><span class="p">)),</span><span class="s1">'png'</span><span class="p">);</span>
	<span class="nb">delete</span><span class="p">(</span><span class="n">f1</span><span class="p">);</span>
	<span class="nb">delete</span><span class="p">(</span><span class="n">f2</span><span class="p">);</span>
	<span class="nb">delete</span><span class="p">(</span><span class="n">f3</span><span class="p">);</span>
	<span class="k">for</span> <span class="n">jj</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="nb">length</span><span class="p">(</span><span class="n">tmpPlot</span><span class="p">)</span>
		<span class="nb">delete</span><span class="p">(</span><span class="n">tmpPlot</span><span class="p">(</span><span class="n">jj</span><span class="p">));</span>
	<span class="k">end</span>
	
	<span class="nb">pause</span><span class="p">(</span><span class="mf">0.001</span><span class="p">)</span>
<span class="k">end</span></code></pre></figure>

<p>Gif below shows the robot discovering the landmarks. Black circles are the computed estimates while the red dots are the measurements of the landmarks.</p>

<p><img src="https://szonov.com/assets/SLAM/outputName.gif" alt=""></p>

<p>How close were the estimates? The blue stars are the true landmark locations, red dots are measurements throughout and black circles are the computed final estimates.</p>

<p><img src="https://szonov.com/assets/SLAM/setup3.png" alt=""></p>

<p>If you want to see the code used here then see <a href="https://szonov.com/assets/SLAM/script.m">script.m</a> and assist <a href="ddekf_update_phase.m">file</a>. Also check out this <a href="https://github.com/randvoorhies/SimpleSLAM">repository</a> that was inspiration for this little project.</p>

<script defer>
    function isMobileOnlyView() {
        return window.matchMedia("(max-width: 767px)").matches;
    }

    if (isMobileOnlyView()) {
        
        let popupButtons = [];
        let targetSections = [];
        let sidebars = [];
        let closebuttons = [];
        let sections_in_target_section = [];
        let links_in_sidebar = [];
        let i = 1;
        let popupButton;
        while ((popupButton = document.getElementById(`popup-button-${i}`)) !== null) {
            popupButtons.push(popupButton);
            const targetSection = document.getElementById(`target-section-${i}`)
            targetSections.push(targetSection);
            const sidebar = document.getElementById(`sidebar-${i}`);
            sidebars.push(sidebar);
            closebuttons.push(document.getElementById(`close-buttons-${i}`));

            const mobileSections = targetSection.querySelectorAll('[id^="mobile-section"]');
            // Convert NodeList to an array and push it to sections_in_target_section
            sections_in_target_section.push(Array.from(mobileSections));

            const links = sidebar.querySelectorAll('a');
            links_in_sidebar.push(Array.from(links));
            i++;
        }
        
        let popupButtonCount = i - 1;
        
        window.addEventListener('scroll', function() {
            for (let i = 1; i <= popupButtonCount; i++) {
                const popupButton = popupButtons[i-1];
                const targetSection = targetSections[i-1]
                const sectionPosition = targetSection.getBoundingClientRect();
                const viewportHeight = window.innerHeight;
                
                // Check if the target section is halfway through the viewport
                if (sectionPosition.top < viewportHeight / 2 && sectionPosition.bottom > viewportHeight / 2) {
                    popupButton.classList.add('show'); // Show the button
                } else {
                    popupButton.classList.remove('show'); // Hide the button
                }
                
                const sidebar = sidebars[i-1];
                // Hide sidebar on scroll (only on mobile)
                if (sidebar.classList.contains('show') && window.innerWidth <= 768) {
                    sidebar.classList.remove('show'); // Hide the sidebar
                }
                
                // Highlight active link based on scroll position
                let currentSectionId = '';
                sections_in_target_section[i-1].forEach(section => {
                    const sectionTop = section.getBoundingClientRect().top;
                    const sectionBottom = section.getBoundingClientRect().bottom;

                    // Check if the section is in view and at the top of the viewport
                    if (sectionTop <= viewportHeight / 2 && sectionBottom > viewportHeight / 2) {
                        currentSectionId = section.id;
                    }
                });
                
                 links_in_sidebar[i-1].forEach(link => {
                    link.classList.remove('active');
                    if (link.getAttribute('href') === `#${currentSectionId}`) {
                        link.classList.add('active'); // Highlight active link
                    }
                });
            }
        });
        
        for (let i = 1; i <= popupButtonCount; i++) {
            // Function to toggle sidebar visibility
            let popupButton = popupButtons[i-1];
            popupButton.addEventListener('click', function() {
                const sidebar = sidebars[i-1];
                sidebar.classList.toggle('show'); // Toggle sidebar visibility
                if (sidebar.classList.contains('show')) {
                    // Calculate the sidebar height and set its position
                    const sidebarHeight = sidebar.scrollHeight; // Use scrollHeight for accurate height
                    const windowHeight = window.innerHeight; // Get the window height
                    const topPosition = (windowHeight / 2); // - (sidebarHeight / 2); // Calculate top position
                    sidebar.style.top = `${topPosition}px`; // Set the top position
                    
                    links_in_sidebar[i-1].forEach(link => {
                       if (link.classList.contains('active')) {

                           function delay(time) {
                             return new Promise(resolve => setTimeout(resolve, time));
                           }
                           function scroll_adjust(){
                               // add the delay so that the sidebar can be loaded from zero size
                               // before getting all the various coordinates used in calculation
                               const scrollableElement = link.closest(".mobile-scrollable");
                               const scollableRect = scrollableElement.getBoundingClientRect();
                               const linkRect = link.getBoundingClientRect();
                               
                               if( ( linkRect.y + 100 ) > ( scollableRect.y + scollableRect.height ) || linkRect.y < scollableRect.y){
                                   const scrollTop = linkRect.top - scollableRect.top + scrollableElement.scrollTop - (scollableRect.height / 2) + (link.offsetHeight / 2);
                                   scrollableElement.scrollTo({ top: scrollTop, behavior: 'smooth' });
                               }
                           }
                           
                           delay(1000).then(() =>scroll_adjust() );
                       }
                    })
                }
                
                // Close sidebar when close button is clicked
                closebuttons[i-1].addEventListener('click', function() {
                    sidebar.classList.remove('show'); // Hide the sidebar
                });
                
                // Close sidebar when clicking outside of it
                document.addEventListener('click', function(event) {
                    if (sidebar.classList.contains('show') && !sidebar.contains(event.target) && !popupButton.contains(event.target)) {
                        sidebar.classList.remove('show'); // Hide the sidebar
                    }
                });
                
            });
        }
    } else {
        // for desktop
        window.addEventListener('scroll', () => {
            const sections = document.querySelectorAll('.section');
            const links = document.querySelectorAll('#menu a');
            
            let currentSection = ''
            let current = ''
            
            // highlight the active link based on where the location of scroll
            output_string = window.scrollY + ""
            sections.forEach(section => {
                const sectionTop = section.getBoundingClientRect().top;
                const sectionBottom = section.getBoundingClientRect().bottom;
                
                output_string = output_string + "(" +sectionTop + ", " + sectionBottom + ")"
                if (sectionTop > 50 ) {
                    if(currentSection == ''){
                        currentSection = section
                    }
                    else if(currentSection.getBoundingClientRect().top > 0 && sectionTop < currentSection.getBoundingClientRect().top ){
                        currentSection = section
                    }
                    current = currentSection.getAttribute('id');
                }
                else if (sectionBottom > 50  ){
                    if(currentSection == ''){
                        currentSection = section
                    }
                    else if( sectionBottom < currentSection.getBoundingClientRect().bottom ){
                        currentSection = section
                    }
                    current = currentSection.getAttribute('id');
                }
            });
            
            links.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === `#${current}`) {
                    link.classList.add('active');
                    // For cases when scrollable toc is bigger than screen view
                    // and active link is outside of view
                    const scrollableElement = link.closest(".scrollable");
                    const scollableRect = scrollableElement.getBoundingClientRect();
                    const linkRect = link.getBoundingClientRect();
                    
                    if( ( linkRect.y + 100 ) > ( scollableRect.y + scollableRect.height ) || linkRect.y < scollableRect.y){
                        const scrollTop = linkRect.top - scollableRect.top + scrollableElement.scrollTop - (scollableRect.height / 2) + (link.offsetHeight / 2);
                        scrollableElement.scrollTo({ top: scrollTop, behavior: 'smooth' });
                    }
                }
            });
        });
    }
</script>
</body>
</html>

  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

	<div class="wrapper">

		<!--<p style="color:grey">Welcome to my site. Take a look around and don't be shy, shoot me a message!</p>-->
	</div>
  <div class="wrapper">

    <!--<h2 class="footer-heading">Stan Zonov</h2>-->

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-2">
        <ul class="contact-list">
          <!--<li>Stan Zonov</li>-->
          <!--<li>hello at szonov.com</li>-->
        </ul>
      </div>

      <div class="footer-col  footer-col-1">
	     
        <ul class="social-media-list">
	   <!--
            <p>

<span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
																	<g transform="scale(0.035)">
                  <path fill="#828282" d="M101.3 141.6v228.9h0.3 308.4 0.8V141.6H101.3zM375.7 167.8l-119.7 91.5 -119.6-91.5H375.7zM127.6 194.1l64.1 49.1 -64.1 64.1V194.1zM127.8 344.2l84.9-84.9 43.2 33.1 43-32.9 84.7 84.7L127.8 344.2 127.8 344.2zM384.4 307.8l-64.4-64.4 64.4-49.3V307.8z"/>
																</g>
                </svg>
              </span>

              <span class="username">hello at szonov.com</span>
	    </p>
	    </li>-->


          

          


          


        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text"></p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
