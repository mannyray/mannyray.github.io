<!DOCTYPE html>
<html>

  <head>
  
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Winter Research</title>
  <meta name="description" content="A lot of data nowadays is stored online or in the ‘cloud’, separating clients and servers by kilometres upon kilometres of distance. The client moves their d...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://szonov.com/programming/2016/09/12/winter-research/">
  <link rel="alternate" type="application/rss+xml" title="Stan Zonov" href="https://szonov.com/feed.xml" />
</head>


  <body>
	
    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Stan Zonov</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
	<a class="page-link" href=""></a>
        
		
			<a class="page-link" href="/about/">About</a>
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			<a class="page-link" href="/photos/">Photos</a>
		
        
	<a class="page-link" href="/">Blog</a>
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
 	 
    <h1 class="post-title">Winter Research</h1>
    <p class="post-meta">Sep 12, 2016</p>
  </header>

  <article class="post-content">
    <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<body>
<p style="height:0px;width:0px"></p>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
    .toc_and_content_table{
        border: none;
    }
    .toc {
        width: 25%;
        vertical-align:top;
        border: none;
        padding:0px;
        border: none;
    }
    .content {
        padding: 10px;
        border: none;
    }
    .scrollable{
        height: auto;        /* Allow it to grow based on content */
        max-height: 100vh;
        overflow-y: auto;
    }
    .sticky-top {
        position: -webkit-sticky;
        position: sticky;
        top: 0;
        background: #fff; /* Background for the sticky menu */
    }
    #menu {
        list-style-type: none; /* Remove bullets */
        padding: 0; /* Remove padding */
        margin: 0; /* Remove margin */
    }
    #menu li {
        margin: 5px 0; /* Space between bars */
        position: relative
    }
    #menu a {
        display: block; /* Make the link a block element */
        padding: 2px; /* Space inside the bars */
        background: #f0f0f0; /* Light gray background for bars */
        text-decoration: none; /* Remove underline */
        color: #333; /* Text color */
        border-radius: 4px; /* Rounded corners */
        transition: background 0.3s; /* Smooth background transition */
    }
    #menu a:hover {
        background: #e0e0e0; /* Darker gray on hover */
    }
    .active {
        font-weight: bold;
        color: blue; /* Change the color for highlighting */
    }
    .active::after {
        content: '';
        position: absolute;
        top: 0;
        border-radius: 4px;
        left: 0;
        height: 100%;
        width: 100%;
        background: #007bff; /* Active background color */
        transform: scaleX(0); /* Start with no width */
        transform-origin: left; /* Scale from the left */
        animation: load 0.5s forwards; /* Loading animation */
        background: rgba(0, 123, 255, 0.5); /* Semi-transparent active background color */
    }
    @keyframes load {
        0% {
            transform: scaleX(0); /* Start with no width */
        }
        70% {
            transform:  scaleX(1); /* Scale to full width */
        }
        85% {
            transform: scaleX(0.95); /* Bounce effect */
        }
        100% {
            transform: scaleX(1); /* Return to full width */
        }
    }
    .section {
        border: 0;
        height: 100%;
        margin: 0;
        padding: 0;
        width: 100%;
    }
    
    .desktop-only {
        display: none;
    }
    /* Show mobile paragraph on mobile devices */
    .mobile-only {
        display: block;
    }
    /* Media query for non-mobile devices */
    @media (min-width: 768px) {
        .desktop-only {
            display: block;
        }
        .mobile-only {
            display: none;
        }
    }
    
    /* mobile version*/
    .popup-button {
        font-size: 24px;
        position: fixed;
        top: 50%;
        right: 0;
        transform: translateY(-50%); /* Center vertically */
        padding: 10px 20px;
        background-color: #f0f0f0;
        border-radius: 5px;
        cursor: pointer;
        opacity: 0; /* Start invisible */
        visibility: hidden; /* Initially hidden */
        transition: opacity 0.5s ease, visibility 0.5s ease; /* Fade effect */
    }
    .popup-button.show {
        opacity: 1; /* Fully visible */
        visibility: visible; /* Make it visible */
    }
    .target-section {
        background-color: #f0f0f0;
    }
    .sidebar {
        position: fixed;
        right: 0; /* Align sidebar directly to the right edge */
        width: 200px; /* Set the width of the sidebar */
        max-height: 80vh; /* Limit height for scrolling */
        background: #fff; /* Background for the sidebar */
        padding: 10px; /* Padding inside the sidebar */
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); /* Subtle shadow for depth */
        z-index: 1000; /* Ensure it appears above other elements */
        transform: translate(0, -50%) scale(0); /* Start hidden and minimized */
        transform-origin: right center; /* Scale from the right */
        transition: transform 0.3s ease, visibility 0.5s ease; /* Smooth transition */
        visibility: hidden; /* Initially hidden */
        border: 1px solid #ccc; /* Add a border */
        border-radius: 8px; /* Slightly rounded corners */
    }
    .sidebar.show {
        transform: translate(0, -50%) scale(1); /* Show the sidebar */
        visibility: visible; /* Make it visible */
    }
    .sidebar h3 {
        margin: 0; /* Remove default margin */
        padding: 0; /* Remove default padding */
        height: 40px; /* Set height for better alignment */
    }
    .mobile-scrollable{
        height: auto;        /* Allow it to grow based on content */
        max-height: 70vh;
        overflow-y: auto;
    }
</style>
<p>A lot of data nowadays is stored online or in the ‘cloud’, separating clients and servers by kilometres upon kilometres of distance. The client moves their data to a server with more memory and speed to be able to compute things in the cloud at rates faster than they could ever do so by themselves. The client storing the data on the server has to be able to trust the server and that the server is uncompromised in order to keep their information secure. Ways in which this can be done will be discussed in this post.</p>

<p>Back in December I have worked as a URA for Assistant Professor <a href="https://cs.uwaterloo.ca/~sgorbuno/">Sergey Gorbunov</a> of University of Waterloo in the area of secure storage of information in the cloud. The task was to measure and evaluate different techniques commonly used in cloud based storage as well as to explore the emerging field of searchable symmetric encryption.</p>

<p>The model used for testing is a very simple client-server model. The server stores many text files and provides clients with the ability to search/query the files containing requested words/phrase. Here is an illustration below (figure 1):</p>

<p><img src="https://szonov.com/assets/regular_search.png" alt="image"></p>

<p>There were two techniques tested in the model. The first involved simply storing the data on server without any modification (same as in the picture above) whereas the second approach involved storing the files in an encrypted format. An encrypted file was a mapping of the original text file where every word was individually encrypted using the same key with preserved order overall. Here is an illustration of a mapping (figure 2):</p>

<p><img src="https://szonov.com/assets/encryption_of_file.png" alt="image"></p>

<p>The encryption in the example above was completely made up by me to help explain the file transformation (we can discuss the actual encryption details a little later). However, one thing I do want the reader to observe in my made up example is that “abc” recorded twice in file1.txt gets mapped on to “xxyxasd” twice with the order preserved. In fact, all the files stored on server are encrypted in such a way that “abc” in file1 and file2 would map to “xxyxasd” in encrypt_file1 and encrypt_file2 in the same order that they originally appeared.</p>

<p>Now that we have our encrypted files stored on server, how do we execute search as shown in figure 1?</p>

<p>Since we only have the encrypted files stored on server we can’t search for “abc” on the server directly anymore since it has “xxyxasd” in its original place. Hence we have to be able to encrypt our search word in advance before sending it to the server. Our encrypted client-server model now looks something like this when searching for “abc” (figure 3):</p>

<p><img src="https://szonov.com/assets/encrypted_send.png" alt="image"></p>

<p>The actual encryption used in my model was AES - ECB mode where a given plaintext is divided into blocks and each block is encrypted individually.</p>

<h4 id="comparing-the-techniques-at-a-glance">Comparing the techniques at a glance</h4>

<p>The first technique is the simplest as it does not change the original data. Anyone with this information can easily read and interpret it. The downside is that the files stored on the server are stored in an unencrypted format meaning that anyone with access to the server can view the data. The intended users of the server have to be confident in the security of the server.</p>

<p>The second technique is the encrypted format. The data on the server cannot be easily read and interpreted but involves more time in initial encryption setup as well as decryption upon data retrieval. From this setup we can already get a sense that there is a little more work involved in handling the data.</p>

<h4 id="comparing-the-techniques-with-an-experiment">Comparing the techniques with an experiment</h4>

<p>I went on to set up the two techniques in order to be able to compare the two to each other. Here are the details:</p>

<p>The server-client in the project was to model a health info-patient setup. 16.5MB worth of formatted health related 2270 articles from Wikipedia were downloaded and stored on the server using Elasticsearch. In addition, 1197 health related queries were sourced from the <a href="https://en.wikipedia.org/wiki/AOL_search_data_leak">AOL leak</a> for use by the client.</p>

<p>The client would send the queries, to the server (ran on uwaterloo server) to then receive the top 20 matches of articles (if there were any). The queries would return the documents that contained the individual words that best matched the query. The search algorithm on the server/Elasticsearch provided a degree of approximation to the words/phrases to accommodate for spelling mistakes and over-specific queries (similar to what google search does). In the case of encryption, the Wikipedia articles were first encrypted before being stored on server and the queries from client were first encrypted before sent on to the server.</p>

<p>Further details on implementation can be found here: <a href="https://github.com/mannyray/es_basic_encryption">https://github.com/mannyray/es_basic_encryption</a></p>

<h4 id="comparing-the-numbers">Comparing the numbers</h4>

<p>The initial Wikipedia articles were 16.5 MB in size, which when encrypted, inflated to about 85MB. The expansion of data was expected as the string ‘a’ could end up being encrypted into ‘0x731b31922c9228465e0f0ea51ea7f’ (hex format). This humble sample size was used to get a basic comparison and understanding of the two methods of data storage.</p>

<p><em>Accuracy</em></p>

<p>Some queries were expected to be unmatched since the queries could have been too specific or out of range for the limited data present in database. After storing the data on Elasticsearch and querying the results for regular storage the server was able to match for 42% of the time and for the encrypted 34% of the time. The discrepancy was expected since it is impossible to approximate spelling with encrypted words. Further analysis of the mismatch proved this theory showing that only 0.25% queries were matched only for encrypted(not regular) and 7.6% only for regular.</p>

<p><em>Query time</em></p>

<p>The query time on Elasticsearch was much greater for the encrypted version. In fact, 79% were faster for regular text and an additional 5% were slower for regular only because encrypted could not match anything at all while regular could. The average query time for regular was 2.64ms and 6ms for encrypted. Here is a cdf of the times (blue for regular and red for encrypted ~ showing that regular has the speed advantage) where x is time in milliseconds:</p>

<p><img src="https://szonov.com/assets/cdf.png" alt="image"></p>

<p>The regular (blue) technique can be observed to be much faster than encrypted version.</p>

<h4 id="discussion">Discussion</h4>

<p>Both methods of storing data, encrypted vs unencrypted, each have their respective benefits and drawbacks in the categories of speed, security and usability.</p>

<p><em>Speed:</em></p>

<p>Speed is a major concern when storing/retrieving data. For a large company with many servers and many clients, good speed would be crucial in running a successful operation. With encryption we saw a significant slowdown in search time as well as a significant inflation in data size. In a real life situation this would translate to more memory expense and time to execute queries.</p>

<p>The unencrypted format is compact and fast. It would not require the data to be encrypted ahead of time for storage or decryption upon data retrieval from server, saving even more time overall.</p>

<p><em>Security:</em></p>

<p>There is no doubt that unecrypted is insecure. It has to be to stored in a safe location or deemed to be safe for everyone to see. However, ‘stored in a safe location’ can go wrong, as seen in the <a href="http://www.theglobeandmail.com/news/british-columbia/hard-drive-with-personal-info-on-34-million-bc-and-yukon-students-lost/article26478731/">BC data leak</a> and the AOL leak (used in this experiment).</p>

<p>The encrypted version in this scenario encrypts every word individually before storing the documents. Unfortunately, this is only slightly more secure than the unecrypted version since the encrypted version is susceptible to a frequency analysis (<a href="https://en.wikipedia.org/wiki/History_of_cryptography#Medieval_and_Renaissance_cryptography">one of the oldest decryption attacks</a>). For example, if one of our encrypted files has ‘0x872343…..a98’ as the most frequent word then we can take an educated guess and say that this matches with the word ‘the’ (a very frequent English word) and continue working this way until we have cracked the overall text to a meaningful message.</p>

<p>A potential fix to this: the encrypted version would have had to change the encryption of identical words by using a counter to incorporate into the IV of AES encryption which would make all version of the same encrypted word different. This would make it secure from frequency analysis but would greatly increase search time overall as you now have to search for all versions of the encrypted word (and know how many there are in advance).</p>

<p><em>Usability:</em></p>

<p>Finally, usability is also an issue when it comes to data storage. It is the most easiest to store and use the data in an unecrypted format. Whereas the encrypted format is very rigid and hard to analyse as was shown in the accuracy section previously. The speed also plays a role in usability where the encrypted speed is very unattractive.</p>

<p><em>Conclusion</em></p>

<p>To conclude it is worth to say that both encrypted and unecrypted formats have their advantages and disadvantages as this experiment was able to show. Encrypted provides more security while unecrypted provides ease and speed of use. A perfect blend of both is desirable to provide the best of both worlds to the user. One of the areas of research covering this blend is searchable symmetric encryption (sse). Techniques in sse protect the data from the unwanted eye but give the ability of more ease of search for the intended user. The area of research is relatively new and is growing rapidly with lots of information online for the curious reader.</p>

<script>
    function isMobileOnlyView() {
        return window.matchMedia("(max-width: 767px)").matches;
    }

    if (isMobileOnlyView()) {
        
        let popupButtons = [];
        let targetSections = [];
        let sidebars = [];
        let closebuttons = [];
        let sections_in_target_section = [];
        let links_in_sidebar = [];
        let i = 1;
        let popupButton;
        while ((popupButton = document.getElementById(`popup-button-${i}`)) !== null) {
            popupButtons.push(popupButton);
            const targetSection = document.getElementById(`target-section-${i}`)
            targetSections.push(targetSection);
            const sidebar = document.getElementById(`sidebar-${i}`);
            sidebars.push(sidebar);
            closebuttons.push(document.getElementById(`close-buttons-${i}`));

            const mobileSections = targetSection.querySelectorAll('[id^="mobile-section"]');
            // Convert NodeList to an array and push it to sections_in_target_section
            sections_in_target_section.push(Array.from(mobileSections));

            const links = sidebar.querySelectorAll('a');
            links_in_sidebar.push(Array.from(links));
            i++;
        }
        
        let popupButtonCount = i - 1;
        
        window.addEventListener('scroll', function() {
            for (let i = 1; i <= popupButtonCount; i++) {
                const popupButton = popupButtons[i-1];
                const targetSection = targetSections[i-1]
                const sectionPosition = targetSection.getBoundingClientRect();
                const viewportHeight = window.innerHeight;
                
                // Check if the target section is halfway through the viewport
                if (sectionPosition.top < viewportHeight / 2 && sectionPosition.bottom > viewportHeight / 2) {
                    popupButton.classList.add('show'); // Show the button
                } else {
                    popupButton.classList.remove('show'); // Hide the button
                }
                
                const sidebar = sidebars[i-1];
                // Hide sidebar on scroll (only on mobile)
                if (sidebar.classList.contains('show') && window.innerWidth <= 768) {
                    sidebar.classList.remove('show'); // Hide the sidebar
                }
                
                // Highlight active link based on scroll position
                let currentSectionId = '';
                sections_in_target_section[i-1].forEach(section => {
                    const sectionTop = section.getBoundingClientRect().top;
                    const sectionBottom = section.getBoundingClientRect().bottom;

                    // Check if the section is in view and at the top of the viewport
                    if (sectionTop <= viewportHeight / 2 && sectionBottom > viewportHeight / 2) {
                        currentSectionId = section.id;
                    }
                });
                
                 links_in_sidebar[i-1].forEach(link => {
                    link.classList.remove('active');
                    if (link.getAttribute('href') === `#${currentSectionId}`) {
                        link.classList.add('active'); // Highlight active link
                    }
                });
            }
        });
        
        for (let i = 1; i <= popupButtonCount; i++) {
            // Function to toggle sidebar visibility
            let popupButton = popupButtons[i-1];
            popupButton.addEventListener('click', function() {
                const sidebar = sidebars[i-1];
                sidebar.classList.toggle('show'); // Toggle sidebar visibility
                if (sidebar.classList.contains('show')) {
                    // Calculate the sidebar height and set its position
                    const sidebarHeight = sidebar.scrollHeight; // Use scrollHeight for accurate height
                    const windowHeight = window.innerHeight; // Get the window height
                    const topPosition = (windowHeight / 2); // - (sidebarHeight / 2); // Calculate top position
                    sidebar.style.top = `${topPosition}px`; // Set the top position
                    
                    links_in_sidebar[i-1].forEach(link => {
                       if (link.classList.contains('active')) {

                           function delay(time) {
                             return new Promise(resolve => setTimeout(resolve, time));
                           }
                           function scroll_adjust(){
                               // add the delay so that the sidebar can be loaded from zero size
                               // before getting all the various coordinates used in calculation
                               const scrollableElement = link.closest(".mobile-scrollable");
                               const scollableRect = scrollableElement.getBoundingClientRect();
                               const linkRect = link.getBoundingClientRect();
                               
                               if( ( linkRect.y + 100 ) > ( scollableRect.y + scollableRect.height ) || linkRect.y < scollableRect.y){
                                   const scrollTop = linkRect.top - scollableRect.top + scrollableElement.scrollTop - (scollableRect.height / 2) + (link.offsetHeight / 2);
                                   scrollableElement.scrollTo({ top: scrollTop, behavior: 'smooth' });
                               }
                           }
                           
                           delay(1000).then(() =>scroll_adjust() );
                       }
                    })
                }
                
                // Close sidebar when close button is clicked
                closebuttons[i-1].addEventListener('click', function() {
                    sidebar.classList.remove('show'); // Hide the sidebar
                });
                
                // Close sidebar when clicking outside of it
                document.addEventListener('click', function(event) {
                    if (sidebar.classList.contains('show') && !sidebar.contains(event.target) && !popupButton.contains(event.target)) {
                        sidebar.classList.remove('show'); // Hide the sidebar
                    }
                });
                
            });
        }
    } else {
        // for desktop
        window.addEventListener('scroll', () => {
            const sections = document.querySelectorAll('.section');
            const links = document.querySelectorAll('#menu a');
            
            let currentSection = ''
            let current = ''
            
            // highlight the active link based on where the location of scroll
            output_string = window.scrollY + ""
            sections.forEach(section => {
                const sectionTop = section.getBoundingClientRect().top;
                const sectionBottom = section.getBoundingClientRect().bottom;
                
                output_string = output_string + "(" +sectionTop + ", " + sectionBottom + ")"
                if (sectionTop > 50 ) {
                    if(currentSection == ''){
                        currentSection = section
                    }
                    else if(currentSection.getBoundingClientRect().top > 0 && sectionTop < currentSection.getBoundingClientRect().top ){
                        currentSection = section
                    }
                    current = currentSection.getAttribute('id');
                }
                else if (sectionBottom > 50  ){
                    if(currentSection == ''){
                        currentSection = section
                    }
                    else if( sectionBottom < currentSection.getBoundingClientRect().bottom ){
                        currentSection = section
                    }
                    current = currentSection.getAttribute('id');
                }
            });
            
            links.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === `#${current}`) {
                    link.classList.add('active');
                    // For cases when scrollable toc is bigger than screen view
                    // and active link is outside of view
                    const scrollableElement = link.closest(".scrollable");
                    const scollableRect = scrollableElement.getBoundingClientRect();
                    const linkRect = link.getBoundingClientRect();
                    
                    if( ( linkRect.y + 100 ) > ( scollableRect.y + scollableRect.height ) || linkRect.y < scollableRect.y){
                        const scrollTop = linkRect.top - scollableRect.top + scrollableElement.scrollTop - (scollableRect.height / 2) + (link.offsetHeight / 2);
                        scrollableElement.scrollTo({ top: scrollTop, behavior: 'smooth' });
                    }
                }
            });
        });
    }
</script>
</body>
</html>

  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

	<div class="wrapper">

		<!--<p style="color:grey">Welcome to my site. Take a look around and don't be shy, shoot me a message!</p>-->
	</div>
  <div class="wrapper">

    <!--<h2 class="footer-heading">Stan Zonov</h2>-->

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-2">
        <ul class="contact-list">
          <!--<li>Stan Zonov</li>-->
          <!--<li>hello at szonov.com</li>-->
        </ul>
      </div>

      <div class="footer-col  footer-col-1">
	     
        <ul class="social-media-list">
	   <!--
            <p>

<span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
																	<g transform="scale(0.035)">
                  <path fill="#828282" d="M101.3 141.6v228.9h0.3 308.4 0.8V141.6H101.3zM375.7 167.8l-119.7 91.5 -119.6-91.5H375.7zM127.6 194.1l64.1 49.1 -64.1 64.1V194.1zM127.8 344.2l84.9-84.9 43.2 33.1 43-32.9 84.7 84.7L127.8 344.2 127.8 344.2zM384.4 307.8l-64.4-64.4 64.4-49.3V307.8z"/>
																</g>
                </svg>
              </span>

              <span class="username">hello at szonov.com</span>
	    </p>
	    </li>-->


          

          


          


        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text"></p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
