<!DOCTYPE html>
<html>

  <head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-39729658-3"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-39729658-3');
</script>


  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Beautiful 3 Set</title>
  <meta name="description" content="I was on hackerrank the other day trying to solve ‘Beautiful 3 Set’. The problem goes like this:">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://szonov.com/programming/2017/07/14/Beautiful-3-set/">
  <link rel="alternate" type="application/rss+xml" title="Stan Zonov" href="https://szonov.com/feed.xml" />
</head>


  <body>
	
    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Stan Zonov</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
	<a class="page-link" href=""></a>
        
		
			<a class="page-link" href="/about/">About</a>
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			<a class="page-link" href="/photos/">Photos</a>
		
        
	<a class="page-link" href="/">Blog</a>
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
 	 
    <h1 class="post-title">Beautiful 3 Set</h1>
    <p class="post-meta">Jul 14, 2017</p>
  </header>

  <article class="post-content">
    <p>I was on hackerrank the other day trying to solve <a href="https://www.hackerrank.com/challenges/beautiful-3-set">‘Beautiful 3 Set’</a>. The problem goes like this:</p>

<p>You are given an integer <code class="language-plaintext highlighter-rouge">n</code>. A set, <code class="language-plaintext highlighter-rouge">S</code>, of triples <code class="language-plaintext highlighter-rouge">(x_i, y_i, z_i)</code> is beautiful if and only if:</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">0 &lt;= x_i, y_i, z_i</code></li>
  <li><code class="language-plaintext highlighter-rouge">x_i + y_i + z_i = n</code>, For all <code class="language-plaintext highlighter-rouge">i</code> such that <code class="language-plaintext highlighter-rouge">1 &lt;= i &lt;= |S|</code></li>
  <li>Let X be the set of different <code class="language-plaintext highlighter-rouge">x_i</code>’s in S, Y be the set of different <code class="language-plaintext highlighter-rouge">y_i</code>’s in S, and Z be the set of different <code class="language-plaintext highlighter-rouge">z_i</code> in S. Then <code class="language-plaintext highlighter-rouge">|X| = |Y| = |Z| = |S|</code></li>
</ol>

<p>The third condition means that all <code class="language-plaintext highlighter-rouge">x_i</code>’s are pairwise distinct. The same goes for <code class="language-plaintext highlighter-rouge">y_i</code> and <code class="language-plaintext highlighter-rouge">z_i</code>.</p>

<p>Problem: Given <code class="language-plaintext highlighter-rouge">n</code>, find any beautiful set having maximum number of elements. Then print the cardinality of <code class="language-plaintext highlighter-rouge">S</code> on a new line, followed by <code class="language-plaintext highlighter-rouge">|S|</code> lines where each line contains 3 space-separated integers describing the respective values of <code class="language-plaintext highlighter-rouge">x_i</code>, <code class="language-plaintext highlighter-rouge">y_i</code> and <code class="language-plaintext highlighter-rouge">z_i</code>.</p>

<p>Input Format:</p>

<p>A sample integer, n. (1 &lt;= n &lt;= 300)</p>

<h1 id="solution">Solution</h1>

<p>The solution to this problem is not obvious. Writing out the testcases for the first few <code class="language-plaintext highlighter-rouge">n</code> is difficult for verification and the questions of uniqueness for each <code class="language-plaintext highlighter-rouge">n</code> comes up. Is there a quick and easy way of coming up with the solution without having to brute force? The answer to the question is <em>yes</em>, because otherwise hackerrank will reject the slow solution. There must be a quick solution and we shall find it (not always the case in general).</p>

<p>At this point I had no real intuition on the problem and decided to brute force the problem first. For the brute force approach, a basic outline of the strategy is to come up with all potential <code class="language-plaintext highlighter-rouge">S</code> sets and store the largest ones of them for each <code class="language-plaintext highlighter-rouge">n</code>. We don’t know if these <code class="language-plaintext highlighter-rouge">S</code> sets are unique(excluding column <code class="language-plaintext highlighter-rouge">-(x|y|z)</code> switching) for a given <code class="language-plaintext highlighter-rouge">n</code> so we will have to store them all. Now let’s get into the specifics of our strategy:</p>

<p>For each <code class="language-plaintext highlighter-rouge">n</code> we will store all <code class="language-plaintext highlighter-rouge">S</code> that satisfy the first three conditions described in the problem description. To generate a single <code class="language-plaintext highlighter-rouge">S</code>, we need some sort of global set to choose from. In other words, we need to generate all valid <code class="language-plaintext highlighter-rouge">(x_i, y_i, z_i)</code> triples as our basis. Each <code class="language-plaintext highlighter-rouge">(x|y|z)_i</code> is a number from <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">n</code> (inclusive) and the triplets thus can be generated using a nested for loop with indexes <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">j</code> (once you know the first two numbers then you know the last <code class="language-plaintext highlighter-rouge">z</code> number since <code class="language-plaintext highlighter-rouge">x+y+z=n</code>). This gives an upper bound of <code class="language-plaintext highlighter-rouge">O(n^2)</code> pairs.</p>

<p>Once you have generated all the possible triplets and have filtered all the invalid ones out by the second condition, then you can start generating potential <code class="language-plaintext highlighter-rouge">S</code> candidates. For any given set <code class="language-plaintext highlighter-rouge">S</code>, each existing triplet in the basis is either in <code class="language-plaintext highlighter-rouge">S</code> or not ~ a binary choice. The binary choice is a good hint on some sort of recursive approach. By checking all potential <code class="language-plaintext highlighter-rouge">S</code> our runtime for this will be <code class="language-plaintext highlighter-rouge">O(2^{|triplet_basis_set_size})</code> which has an upper bound. Definitely won’t work for <code class="language-plaintext highlighter-rouge">n=300</code> on hackerrank.</p>

<p>Thus the runtime of our brute force approach is <code class="language-plaintext highlighter-rouge">O(2^{n^2})</code> (it is easy to optimize the brute force algorithm… but it would still be too slow for hackerrank). That is crazy slow! This is why we are doing this brute force approach on our machine and not hackerrank. Here is the brute force code:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">n_limit</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

<span class="kt">bool</span> <span class="nf">is_file_exist</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fileName</span><span class="p">){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="n">infile</span><span class="p">(</span><span class="n">fileName</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">infile</span><span class="p">.</span><span class="n">good</span><span class="p">();</span>
<span class="p">}</span>


<span class="cm">/*
x,y,z array are responsible for storing the basis of triples from which we select
The ith indeces of these arrays contain the ith triple.

index represents the current index we are looking at in our recursive binary method

//curNum is the current number we are processing (from n_limit)
this is useful for file writing/appending
*/</span>
<span class="kt">int</span> <span class="nf">generatingS</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span><span class="kt">int</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span><span class="kt">int</span> <span class="o">*</span> <span class="n">z</span><span class="p">,</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span><span class="kt">int</span> <span class="n">arrLength</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">x_cov</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">y_cov</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">z_cov</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max</span><span class="p">,</span> <span class="kt">int</span> <span class="n">curNum</span><span class="p">){</span>
	
	<span class="c1">//not enough space left to maximize set</span>
	<span class="c1">//TODO: implement this feature</span>

	<span class="k">if</span><span class="p">(</span><span class="n">index</span><span class="o">==</span><span class="n">arrLength</span><span class="p">){</span>
		<span class="c1">//we reached the bottom. check the set size by counting x_cov</span>
		<span class="c1">//and returning that number </span>
		<span class="kt">int</span> <span class="n">size</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">curNum</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
			<span class="k">if</span><span class="p">(</span><span class="n">x_cov</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">!=</span><span class="mi">0</span><span class="p">){</span>
				<span class="n">size</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span><span class="p">(</span><span class="n">max</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">){</span><span class="c1">//current entry is not bigger</span>
			<span class="k">return</span> <span class="n">max</span><span class="p">;</span>
		<span class="p">}</span>			
		<span class="c1">//write it to file</span>
		
		<span class="n">std</span><span class="o">::</span><span class="n">ofstream</span> <span class="n">outfile</span><span class="p">;</span>

		<span class="n">stringstream</span> <span class="n">ss</span><span class="p">;</span>
		<span class="n">ss</span><span class="o">&lt;&lt;</span><span class="n">curNum</span><span class="o">&lt;&lt;</span><span class="s">".txt"</span><span class="p">;</span>
		
		<span class="n">outfile</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="n">ss</span><span class="p">.</span><span class="n">str</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">ios_base</span><span class="o">::</span><span class="n">app</span><span class="p">);</span>
		<span class="n">outfile</span><span class="o">&lt;&lt;</span><span class="n">size</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">curNum</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
			<span class="k">if</span><span class="p">(</span><span class="n">x_cov</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">!=</span><span class="mi">0</span><span class="p">){</span><span class="c1">//output out all the pairs</span>
				<span class="n">outfile</span><span class="o">&lt;&lt;</span><span class="n">x</span><span class="p">[</span><span class="n">x_cov</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="s">" "</span><span class="o">&lt;&lt;</span><span class="n">y</span><span class="p">[</span><span class="n">x_cov</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="s">" "</span><span class="o">&lt;&lt;</span><span class="n">z</span><span class="p">[</span><span class="n">x_cov</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span><span class="n">outfile</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>

		
		<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
	<span class="p">}</span>
	

	<span class="c1">//assume that (x[index], y[index], z[index]) is in S</span>
	<span class="c1">//in order to make this assumption valid we need to check if </span>
	<span class="c1">//(x|y|z)[index] has already been tagged in (x|y|z)_cov[(x|y|z)[index]]</span>
	<span class="c1">//This is an optimization that says if this triplet can't possibly be</span>
	<span class="c1">//part of the solution the don't recurse further with assumption that it is</span>
	<span class="c1">//part of solution</span>
	<span class="k">if</span><span class="p">(</span><span class="n">x_cov</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">index</span><span class="p">]]</span><span class="o">==</span><span class="mi">0</span><span class="o">&amp;&amp;</span><span class="n">y_cov</span><span class="p">[</span><span class="n">y</span><span class="p">[</span><span class="n">index</span><span class="p">]]</span><span class="o">==</span><span class="mi">0</span><span class="o">&amp;&amp;</span><span class="n">z_cov</span><span class="p">[</span><span class="n">z</span><span class="p">[</span><span class="n">index</span><span class="p">]]</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
		<span class="c1">//tag so that inner layers of recursion now that the numbers in triplet</span>
		<span class="c1">//are in use</span>
		<span class="n">x_cov</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">index</span><span class="p">]]</span><span class="o">=</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">y_cov</span><span class="p">[</span><span class="n">y</span><span class="p">[</span><span class="n">index</span><span class="p">]]</span><span class="o">=</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">z_cov</span><span class="p">[</span><span class="n">z</span><span class="p">[</span><span class="n">index</span><span class="p">]]</span><span class="o">=</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">max</span> <span class="o">=</span> <span class="n">generatingS</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">arrLength</span><span class="p">,</span><span class="n">x_cov</span><span class="p">,</span><span class="n">y_cov</span><span class="p">,</span><span class="n">z_cov</span><span class="p">,</span><span class="n">max</span><span class="p">,</span><span class="n">curNum</span><span class="p">);</span>
		
		<span class="c1">//untag the values</span>
		<span class="n">x_cov</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">index</span><span class="p">]]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
		<span class="n">y_cov</span><span class="p">[</span><span class="n">y</span><span class="p">[</span><span class="n">index</span><span class="p">]]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
		<span class="n">z_cov</span><span class="p">[</span><span class="n">z</span><span class="p">[</span><span class="n">index</span><span class="p">]]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="c1">//assume that (x[index], y[index], z[index]) is not in S</span>
	<span class="n">max</span> <span class="o">=</span> <span class="n">generatingS</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">arrLength</span><span class="p">,</span><span class="n">x_cov</span><span class="p">,</span><span class="n">y_cov</span><span class="p">,</span><span class="n">z_cov</span><span class="p">,</span><span class="n">max</span><span class="p">,</span><span class="n">curNum</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">max</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">n_limit</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">){</span>
		<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">n</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">upperBound</span> <span class="o">=</span> <span class="n">n</span><span class="o">*</span><span class="n">n</span><span class="p">;</span>
		<span class="kt">int</span> <span class="o">*</span> <span class="n">basis_x</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">upperBound</span><span class="p">];</span>
		<span class="kt">int</span> <span class="o">*</span> <span class="n">basis_y</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">upperBound</span><span class="p">];</span>
		<span class="kt">int</span> <span class="o">*</span> <span class="n">basis_z</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">upperBound</span><span class="p">];</span>
		<span class="c1">//first generate the triplet basis</span>
		<span class="c1">//(since i,j,k start at zero then condition 1 auto satisfied) </span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
			<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
				<span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="n">j</span><span class="o">-</span><span class="n">i</span><span class="p">;</span>
				<span class="c1">//satifies condition 2: add to our basis</span>
				<span class="n">basis_x</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
				<span class="n">basis_y</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
				<span class="n">basis_z</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
				<span class="c1">//cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;" "&lt;&lt;k&lt;&lt;endl;</span>
				<span class="n">index</span><span class="o">++</span><span class="p">;</span>	
			<span class="p">}</span>
		<span class="p">}</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">index</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span><span class="c1">//continue;</span>
		
		<span class="c1">//output all pairs</span>
		<span class="c1">//for(int i = 0; i &lt; index; i++){</span>
			<span class="c1">//cout&lt;&lt;basis_x[index]&lt;&lt;" "&lt;&lt;basis_y[index]&lt;&lt;" "&lt;&lt;basis_z[index]&lt;&lt;endl;</span>
		<span class="c1">//}</span>
		
		
		<span class="c1">//we now have our basis and we can now generate all S</span>
		<span class="kt">int</span> <span class="o">*</span><span class="n">x_cov</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
		<span class="kt">int</span> <span class="o">*</span><span class="n">y_cov</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
		<span class="kt">int</span> <span class="o">*</span><span class="n">z_cov</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
			<span class="n">x_cov</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">y_cov</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">z_cov</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">generatingS</span><span class="p">(</span><span class="n">basis_x</span><span class="p">,</span><span class="n">basis_y</span><span class="p">,</span><span class="n">basis_z</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">index</span><span class="p">,</span><span class="n">x_cov</span><span class="p">,</span><span class="n">y_cov</span><span class="p">,</span><span class="n">z_cov</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
		
		
		<span class="k">delete</span> <span class="p">[]</span> <span class="n">basis_x</span><span class="p">;</span>
		<span class="k">delete</span> <span class="p">[]</span> <span class="n">basis_y</span><span class="p">;</span>
		<span class="k">delete</span> <span class="p">[]</span> <span class="n">basis_z</span><span class="p">;</span>
		<span class="k">delete</span> <span class="p">[]</span> <span class="n">x_cov</span><span class="p">;</span>
		<span class="k">delete</span> <span class="p">[]</span> <span class="n">y_cov</span><span class="p">;</span>
		<span class="k">delete</span> <span class="p">[]</span> <span class="n">z_cov</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>I only had the patience to run up to <code class="language-plaintext highlighter-rouge">n = 17</code>. I observed that there were many sets of max <code class="language-plaintext highlighter-rouge">|S|</code> stored for each <code class="language-plaintext highlighter-rouge">n</code>. Given the way the basis was derived and the recursive function ran, I decided to only filter for the first max <code class="language-plaintext highlighter-rouge">|S|</code> printed for each <code class="language-plaintext highlighter-rouge">n</code>. Here are the first for <code class="language-plaintext highlighter-rouge">n=2</code> to <code class="language-plaintext highlighter-rouge">n=17</code>:</p>

<figure class="highlight"><pre><code class="language-plaintext" data-lang="plaintext">n=2:
2
0 0 2
1 1 0
n=3:
3
0 1 2
1 2 0
2 0 1
n=4:
3
0 0 4
1 1 2
2 2 0
n=5:
4
0 0 5
1 2 2
2 3 0
3 1 1

n=6:
5
0 2 4
1 3 2
2 4 0
3 0 3
4 1 1

n=7:
5
0 0 7
1 1 5
2 3 2
3 4 0
4 2 1

n=8:
6
0 0 8
1 3 4
2 4 2
3 5 0
4 1 3
5 2 1

n=9:
7
0 3 6
1 4 4
2 5 2
3 6 0
4 0 5
5 1 3
6 2 1

n=10:
7
0 0 10
1 1 8
2 4 4
3 5 2
4 6 0
5 2 3
6 3 1

n=11:
8
0 0 11
1 4 6
2 5 4
3 6 2
4 7 0
5 1 5
6 2 3
7 3 1

n=12:
9
0 4 8
1 5 6
2 3 7
3 7 2
4 8 0
5 6 1
6 1 5
7 2 3
8 0 4

n=13:
9
0 0 13
1 1 11
2 5 6
3 6 4
4 7 2
5 8 0
6 2 5
7 3 3
8 4 1

n=14:
10
0 0 14
1 5 8
2 6 6
3 4 7
4 8 2
5 9 0
6 7 1
7 2 5
8 3 3
9 1 4

n=15:
11
0 5 10
1 6 8
2 4 9
3 7 5
4 9 2
5 10 0
6 8 1
7 1 7
8 3 4
9 0 6
10 2 3

n=16:
11
0 0 16
1 1 14
2 6 8
3 7 6
4 5 7
5 9 2
6 10 0
7 8 1
8 3 5
9 4 3
10 2 4

n=17:
12
0 0 17
1 6 10
2 7 8
3 5 9
4 8 5
5 10 2
6 11 0
7 9 1
8 2 7
9 4 4
10 1 6
11 3 3</code></pre></figure>

<table>
  <tbody>
    <tr>
      <td>This once again does not tell us much other than the fact that there exists a combination with max</td>
      <td>S</td>
      <td>such that the <code class="language-plaintext highlighter-rouge">x</code>’s can be ordered from <code class="language-plaintext highlighter-rouge">0</code> to some sort of limit. Is it guaranteed that for all n the <code class="language-plaintext highlighter-rouge">x</code>’s can be ordered? We will assume for now that the answer is yes. The pattern for the <code class="language-plaintext highlighter-rouge">y</code> and <code class="language-plaintext highlighter-rouge">z</code> are not clear either. I decided to treat <code class="language-plaintext highlighter-rouge">y-z</code> row values as coordinates on a <code class="language-plaintext highlighter-rouge">y-z</code> plane and plot them. Here is a plot for <code class="language-plaintext highlighter-rouge">n=9</code>:</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th>-</th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
      <th>6</th>
      <th>7</th>
      <th>8</th>
      <th>9</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>0</strong></td>
      <td>0</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td>4</td>
      <td><code class="language-plaintext highlighter-rouge">5</code></td>
      <td>6</td>
      <td>7</td>
      <td>8</td>
      <td>9</td>
    </tr>
    <tr>
      <td><strong>1</strong></td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td><code class="language-plaintext highlighter-rouge">4</code></td>
      <td>5</td>
      <td>6</td>
      <td>7</td>
      <td>8</td>
      <td>9</td>
      <td>10</td>
    </tr>
    <tr>
      <td><strong>2</strong></td>
      <td>2</td>
      <td><code class="language-plaintext highlighter-rouge">3</code></td>
      <td>4</td>
      <td>5</td>
      <td>6</td>
      <td>7</td>
      <td>8</td>
      <td>9</td>
      <td>10</td>
      <td>11</td>
    </tr>
    <tr>
      <td><strong>3</strong></td>
      <td>3</td>
      <td>4</td>
      <td>5</td>
      <td>6</td>
      <td>7</td>
      <td>8</td>
      <td><code class="language-plaintext highlighter-rouge">9</code></td>
      <td>10</td>
      <td>11</td>
      <td>12</td>
    </tr>
    <tr>
      <td><strong>4</strong></td>
      <td>4</td>
      <td>5</td>
      <td>6</td>
      <td>7</td>
      <td><code class="language-plaintext highlighter-rouge">8</code></td>
      <td>9</td>
      <td>10</td>
      <td>11</td>
      <td>12</td>
      <td>13</td>
    </tr>
    <tr>
      <td><strong>5</strong></td>
      <td>5</td>
      <td>6</td>
      <td><code class="language-plaintext highlighter-rouge">7</code></td>
      <td>8</td>
      <td>9</td>
      <td>10</td>
      <td>11</td>
      <td>12</td>
      <td>13</td>
      <td>14</td>
    </tr>
    <tr>
      <td><strong>6</strong></td>
      <td><code class="language-plaintext highlighter-rouge">6</code></td>
      <td>7</td>
      <td>8</td>
      <td>9</td>
      <td>10</td>
      <td>11</td>
      <td>12</td>
      <td>13</td>
      <td>14</td>
      <td>15</td>
    </tr>
    <tr>
      <td><strong>7</strong></td>
      <td>7</td>
      <td>8</td>
      <td>9</td>
      <td>10</td>
      <td>11</td>
      <td>12</td>
      <td>13</td>
      <td>14</td>
      <td>15</td>
      <td>16</td>
    </tr>
    <tr>
      <td><strong>8</strong></td>
      <td>8</td>
      <td>9</td>
      <td>10</td>
      <td>11</td>
      <td>12</td>
      <td>13</td>
      <td>14</td>
      <td>15</td>
      <td>16</td>
      <td>17</td>
    </tr>
    <tr>
      <td><strong>9</strong></td>
      <td>9</td>
      <td>10</td>
      <td>11</td>
      <td>12</td>
      <td>13</td>
      <td>14</td>
      <td>15</td>
      <td>16</td>
      <td>17</td>
      <td>18</td>
    </tr>
  </tbody>
</table>

<p>The rows and column labels represent different potential values for <code class="language-plaintext highlighter-rouge">y</code> and <code class="language-plaintext highlighter-rouge">z</code> (first col is <code class="language-plaintext highlighter-rouge">y</code> values and first row is <code class="language-plaintext highlighter-rouge">z</code> values), the entries on <code class="language-plaintext highlighter-rouge">(y,z)</code> coordinates is the sum: <code class="language-plaintext highlighter-rouge">y+z</code>. This is done because as the <code class="language-plaintext highlighter-rouge">x</code> column values increase one by one then, by definition, the sum of the <code class="language-plaintext highlighter-rouge">y</code> and <code class="language-plaintext highlighter-rouge">z</code> entry must decrease by one. This can be observed visually on the graph as each highlighted number is unique. In addition, we know that all numbers in the <code class="language-plaintext highlighter-rouge">x</code> column are unique and therefore the values in the <code class="language-plaintext highlighter-rouge">y</code> and <code class="language-plaintext highlighter-rouge">z</code> columns must also be unique. Graphically, this translates to no row or column having more than one circled number and the equal sum present in each (anti) diagonal corresponds to a specific x value since <code class="language-plaintext highlighter-rouge">x+y+z=n</code>.</p>

<p>We thus have translated our problem to a different, more visual one. Our translation is somewhat similar to the <a href="https://en.wikipedia.org/wiki/Eight_queens_puzzle">Eight(N) queens puzzle</a>: no highlighted-number/queen can appear in the same column/row/(antidiagonal) on the matrix/chessboard with no pieces below the main <code class="language-plaintext highlighter-rouge">y+z=n</code> diagonal. This translation gives us more insight into the restrictions on the values in the triplets and really drives the point home that this problem is only in terms of <code class="language-plaintext highlighter-rouge">y</code> and <code class="language-plaintext highlighter-rouge">z</code>.</p>

<p>If we go back and plot from <code class="language-plaintext highlighter-rouge">n=2</code> to <code class="language-plaintext highlighter-rouge">n=18</code> then one notices there is no pattern amongst the different <code class="language-plaintext highlighter-rouge">n</code>’s and no natural way to build up the solution. This is slightly disappointing because the printed <code class="language-plaintext highlighter-rouge">n=</code> results were the first from max <code class="language-plaintext highlighter-rouge">|S|</code> found in the brute force code. The hope is that by recording the first result, we would have had caught some sort of relation between the different <code class="language-plaintext highlighter-rouge">n</code>.</p>

<p>Nonetheless, we know what the <code class="language-plaintext highlighter-rouge">|S|</code> size is and have a very simple visual way of coming up with new potential solutions. The simple solution for all <code class="language-plaintext highlighter-rouge">n</code> followed the <code class="language-plaintext highlighter-rouge">n=9</code> pattern (after playing around a bit with the different ‘n-chessboard’ it becomes clear). There are two diagonal like lines. Bottom one starts (bottom-left) at some number (for <code class="language-plaintext highlighter-rouge">n=9</code> it is <code class="language-plaintext highlighter-rouge">(y,z)=(6,0)</code>) and the consecutive entries in diagonal like line are located at <code class="language-plaintext highlighter-rouge">(y-1, z+2)</code> all the way up until <code class="language-plaintext highlighter-rouge">y+z=n</code>. The top diagonal like line starts with <code class="language-plaintext highlighter-rouge">y'=y-1</code> from previous <code class="language-plaintext highlighter-rouge">y</code> when <code class="language-plaintext highlighter-rouge">y+z=n</code>. The first(left-bottom most) <code class="language-plaintext highlighter-rouge">z</code> for top diagonal is <code class="language-plaintext highlighter-rouge">z=1</code>. Top diagonal increases in same fashion as bottom one until bounds of ‘chessboard’ are hit.</p>

<p>Our solution now does not depend on <code class="language-plaintext highlighter-rouge">y</code> and <code class="language-plaintext highlighter-rouge">z</code> but on the left most number of the bottom row. If you plot out the ‘chessboards’ for first 10 <code class="language-plaintext highlighter-rouge">n</code>, then when will notice that the pattern is <code class="language-plaintext highlighter-rouge">mod 3</code> and thus the <code class="language-plaintext highlighter-rouge">O(n)</code> solution is formed:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span><span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">n</span><span class="p">;</span>
    
    <span class="kt">int</span> <span class="n">pairCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">vector</span> <span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">x_y_zPairsOrdered</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">z</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">%</span><span class="mi">3</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
        <span class="n">y</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span> <span class="p">;</span> 
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">%</span><span class="mi">3</span><span class="o">==</span><span class="mi">1</span><span class="p">){</span>
        <span class="n">y</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span><span class="mi">3</span> <span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span><span class="p">{</span><span class="c1">//n%3==2</span>
        <span class="n">y</span><span class="o">=</span><span class="p">(</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span> <span class="p">)</span><span class="o">/</span><span class="mi">3</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">//bottom diagonal from left to right</span>
    <span class="k">do</span><span class="p">{</span>
        <span class="n">x</span><span class="o">=</span><span class="n">n</span><span class="o">-</span><span class="n">y</span><span class="o">-</span><span class="n">z</span><span class="p">;</span>
        <span class="n">x_y_zPairsOrdered</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="n">x_y_zPairsOrdered</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
        <span class="n">x_y_zPairsOrdered</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>
        <span class="n">y</span><span class="o">-=</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">z</span><span class="o">+=</span><span class="mi">2</span><span class="p">;</span>
        <span class="n">pairCount</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="n">z</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">);</span>
    
    <span class="c1">//upper diagonal from left to right</span>
    <span class="n">z</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(;</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span><span class="n">y</span><span class="o">--</span><span class="p">){</span>
        <span class="n">z</span><span class="o">+=</span><span class="mi">2</span><span class="p">;</span>
        <span class="n">x</span><span class="o">=</span><span class="n">n</span><span class="o">-</span><span class="n">z</span><span class="o">-</span><span class="n">y</span><span class="p">;</span>
        <span class="n">pairCount</span><span class="o">++</span><span class="p">;</span>
        <span class="n">x_y_zPairsOrdered</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="n">x_y_zPairsOrdered</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
        <span class="n">x_y_zPairsOrdered</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>
    <span class="p">}</span>
    
    
    <span class="c1">//output:</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">pairCount</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pairCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">x_y_zPairsOrdered</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">3</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="s">" "</span><span class="p">;</span>
        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">x_y_zPairsOrdered</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="s">" "</span><span class="p">;</span>
        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">x_y_zPairsOrdered</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="s">" "</span><span class="p">;</span>
        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    
<span class="p">}</span></code></pre></figure>

<h3 id="conclusion">Conclusion</h3>

<p>The main idea I wanted to push in this article is that in order to solve complex problems such as the ones present in hackerrank, it is OK to take a two step approach and brute it on your machine first. It is OK to try a stupid solution first. It is all about discovery.</p>

<p>Sometimes it is sufficient to simply work through some examples by hand to notice a pattern when solving these problems. However, sometimes that can be difficult to do and verify correctness of and a two step solution can help crack the problem.</p>

<p>Unfortunately, this tip is not the silver/magic bullet to solving ‘Hard’ problems on hackerrank. Oftentimes, the input to the problem is hard to formulate to begin with (like some graph with complex properties). In our case, we were just given a number n, which is easy to generate as input and easy to generate potential output for and test for correctness. Nonetheless, this approach gave me the opportunity to solve the problem by myself and learn something new during the process. That is always welcome.</p>


  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

	<div class="wrapper">

		<!--<p style="color:grey">Welcome to my site. Take a look around and don't be shy, shoot me a message!</p>-->
	</div>
  <div class="wrapper">

    <h2 class="footer-heading">Stan Zonov</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-2">
        <ul class="contact-list">
          <!--<li>Stan Zonov</li>-->
          <li>hello at szonov.com</li>
        </ul>
      </div>

      <div class="footer-col  footer-col-1">
	     
        <ul class="social-media-list">
	   <!--
            <p>

<span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
																	<g transform="scale(0.035)">
                  <path fill="#828282" d="M101.3 141.6v228.9h0.3 308.4 0.8V141.6H101.3zM375.7 167.8l-119.7 91.5 -119.6-91.5H375.7zM127.6 194.1l64.1 49.1 -64.1 64.1V194.1zM127.8 344.2l84.9-84.9 43.2 33.1 43-32.9 84.7 84.7L127.8 344.2 127.8 344.2zM384.4 307.8l-64.4-64.4 64.4-49.3V307.8z"/>
																</g>
                </svg>
              </span>

              <span class="username">hello at szonov.com</span>
	    </p>
	    </li>-->


          

          


          


        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text"></p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
