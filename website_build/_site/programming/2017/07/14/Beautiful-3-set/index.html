<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Beautiful 3 Set</title>
  <meta name="description" content="I was on hackerrank the other day trying to solve ‘Beautiful 3 Set’. The problem goes like this:">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="/programming/2017/07/14/Beautiful-3-set/">
  <link rel="alternate" type="application/rss+xml" title="Stan Zonov" href="/feed.xml" />
</head>


  <body>
	
    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Stan Zonov</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
	<a class="page-link" href=""></a>
        
		
			<a class="page-link" href="/about/">About</a>
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			<a class="page-link" href="/projects/">Projects</a>
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			
		
        
		
			<a class="page-link" href="/photos/">Photos</a>
		
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
 	 
    <h1 class="post-title">Beautiful 3 Set</h1>
    <p class="post-meta">Jul 14, 2017</p>
  </header>

  <article class="post-content">
    <p>I was on hackerrank the other day trying to solve <a href="https://www.hackerrank.com/challenges/beautiful-3-set">‘Beautiful 3 Set’</a>. The problem goes like this:</p>

<p>You are given an integer <code class="highlighter-rouge">n</code>. A set, <code class="highlighter-rouge">S</code>, of triples <code class="highlighter-rouge">(x_i, y_i, z_i)</code> is beautiful if and only if:
 1. <code class="highlighter-rouge">0 &lt;= x_i, y_i, z_i</code>
 2. <code class="highlighter-rouge">x_i + y_i + z_i = n</code>, For all <code class="highlighter-rouge">i</code> such that <code class="highlighter-rouge">1 &lt;= i &lt;= |S|</code>
 3. Let X be the set of different <code class="highlighter-rouge">x_i</code>’s in S, Y be the set of different <code class="highlighter-rouge">y_i</code>’s in S, and Z be the set of different <code class="highlighter-rouge">z_i</code> in S. Then <code class="highlighter-rouge">|X| = |Y| = |Z| = |S|</code></p>

<p>The third condition means that all <code class="highlighter-rouge">x_i</code>’s are pairwise distinct. The same goes for <code class="highlighter-rouge">y_i</code> and <code class="highlighter-rouge">z_i</code>.</p>

<p>Problem: Given <code class="highlighter-rouge">n</code>, find any beautiful set having maximum number of elements. Then print the cardinality of <code class="highlighter-rouge">S</code> on a new line, followed by <code class="highlighter-rouge">|S|</code> lines where each line contains 3 space-separated integers describing the respective values of <code class="highlighter-rouge">x_i</code>, <code class="highlighter-rouge">y_i</code> and <code class="highlighter-rouge">z_i</code>.</p>

<p>Input Format:</p>

<p>A sample integer, n. (1 &lt;= n &lt;= 300)</p>

<h1 id="solution">Solution</h1>

<p>The solution to this problem is not obvious. Writing out the testcases for the first few <code class="highlighter-rouge">n</code> is difficult for verification and the questions of uniqueness for each <code class="highlighter-rouge">n</code> comes up. Is there a quick and easy way of coming up with the solution without having to brute force? The answer to the question is <em>yes</em>, because otherwise hackerrank will reject the slow solution. There must be a quick solution and we shall find it (not always the case in general).</p>

<p>At this point I had no real intuition on the problem and decided to brute force the problem first. For the brute force approach, a basic outline of the strategy is to come up with all potential <code class="highlighter-rouge">S</code> sets and store the largest ones of them for each <code class="highlighter-rouge">n</code>. We don’t know if these <code class="highlighter-rouge">S</code> sets are unique(excluding column <code class="highlighter-rouge">-(x|y|z)</code> switching) for a given <code class="highlighter-rouge">n</code> so we will have to store them all. Now let’s get into the specifics of our strategy:</p>

<p>For each <code class="highlighter-rouge">n</code> we will store all <code class="highlighter-rouge">S</code> that satisfy the first three conditions described in the problem description. To generate a single <code class="highlighter-rouge">S</code>, we need some sort of global set to choose from. In other words, we need to generate all valid <code class="highlighter-rouge">(x_i, y_i, z_i)</code> triples as our basis. Each <code class="highlighter-rouge">(x|y|z)_i</code> is a number from <code class="highlighter-rouge">0</code> to <code class="highlighter-rouge">n</code> (inclusive) and the triplets thus can be generated using a nested for loop with indexes <code class="highlighter-rouge">i</code> and <code class="highlighter-rouge">j</code> (once you know the first two numbers then you know the last <code class="highlighter-rouge">z</code> number since <code class="highlighter-rouge">x+y+z=n</code>). This gives an upper bound of <code class="highlighter-rouge">O(n^2)</code> pairs.</p>

<p>Once you have generated all the possible triplets and have filtered all the invalid ones out by the second condition, then you can start generating potential <code class="highlighter-rouge">S</code> candidates. For any given set <code class="highlighter-rouge">S</code>, each existing triplet in the basis is either in <code class="highlighter-rouge">S</code> or not ~ a binary choice. The binary choice is a good hint on some sort of recursive approach. By checking all potential <code class="highlighter-rouge">S</code> our runtime for this will be <code class="highlighter-rouge">O(2^{|triplet_basis_set_size})</code> which has an upper bound. Definitely won’t work for <code class="highlighter-rouge">n=300</code> on hackerrank.</p>

<p>Thus the runtime of our brute force approach is <code class="highlighter-rouge">O(2^{n^2})</code> (it is easy to optimize the brute force algorithm… but it would still be too slow for hackerrank). That is crazy slow! This is why we are doing this brute force approach on our machine and not hackerrank. Here is the brute force code:
```
#include <iostream>
#include <fstream>
#include <sstream></sstream></fstream></iostream></p>

<p>using namespace std;</p>

<p>int n_limit = 20;</p>

<p>bool is_file_exist(const char *fileName){
    std::ifstream infile(fileName);
    return infile.good();
}</p>

<p>/*
x,y,z array are responsible for storing the basis of triples from which we select
The ith indeces of these arrays contain the ith triple.</p>

<p>index represents the current index we are looking at in our recursive binary method</p>

<p>//curNum is the current number we are processing (from n_limit)
this is useful for file writing/appending
*/
int generatingS(int * x,int * y,int * z,int index,int arrLength, int *x_cov, int *y_cov, int *z_cov, int max, int curNum){</p>

<div class="highlighter-rouge"><pre class="highlight"><code>//not enough space left to maximize set
//TODO: implement this feature

if(index==arrLength){
	//we reached the bottom. check the set size by counting x_cov
	//and returning that number 
	int size=0;
	for(int i = 0; i &lt; curNum+1; i++){
		if(x_cov[i]!=0){
			size++;
		}
	}
	if(max &gt; size){//current entry is not bigger
		return max;
	}			
	//write it to file
	
	std::ofstream outfile;

	stringstream ss;
	ss&lt;&lt;curNum&lt;&lt;".txt";
	
	outfile.open(ss.str(), std::ios_base::app);
	outfile&lt;&lt;size&lt;&lt;endl;
	for(int i = 0; i &lt; curNum+1; i++){
		if(x_cov[i]!=0){//output out all the pairs
			outfile&lt;&lt;x[x_cov[i]-1]&lt;&lt;" "&lt;&lt;y[x_cov[i]-1]&lt;&lt;" "&lt;&lt;z[x_cov[i]-1]&lt;&lt;endl;
		}
	}outfile&lt;&lt;endl;

	
	return size;
}


//assume that (x[index], y[index], z[index]) is in S
//in order to make this assumption valid we need to check if 
//(x|y|z)[index] has already been tagged in (x|y|z)_cov[(x|y|z)[index]]
//This is an optimization that says if this triplet can't possibly be
//part of the solution the don't recurse further with assumption that it is
//part of solution
if(x_cov[x[index]]==0&amp;&amp;y_cov[y[index]]==0&amp;&amp;z_cov[z[index]]==0){
	//tag so that inner layers of recursion now that the numbers in triplet
	//are in use
	x_cov[x[index]]=index+1;
	y_cov[y[index]]=index+1;
	z_cov[z[index]]=index+1;
	max = generatingS(x,y,z,index+1,arrLength,x_cov,y_cov,z_cov,max,curNum);
	
	//untag the values
	x_cov[x[index]]=0;
	y_cov[y[index]]=0;
	z_cov[z[index]]=0;
}

//assume that (x[index], y[index], z[index]) is not in S
max = generatingS(x,y,z,index+1,arrLength,x_cov,y_cov,z_cov,max,curNum);
return max; }
</code></pre>
</div>

<p>int main(){
	for(int n = 2; n &lt;= n_limit; n++){
		cout«n«endl;
		int index = 0;
		int upperBound = n*n;
		int * basis_x = new int[upperBound];
		int * basis_y = new int[upperBound];
		int * basis_z = new int[upperBound];
		//first generate the triplet basis
		//(since i,j,k start at zero then condition 1 auto satisfied) 
		for(int i = 0; i &lt;= n; i++){
			for(int j = 0; j &lt;= n-i; j++){
				int k = n-j-i;
				//satifies condition 2: add to our basis
				basis_x[index] = i;
				basis_y[index] = j;
				basis_z[index] = k;
				//cout«i«” ”«j«” ”«k«endl;
				index++;	
			}
		}cout«index«endl«endl;//continue;</p>

<div class="highlighter-rouge"><pre class="highlight"><code>	//output all pairs
	//for(int i = 0; i &lt; index; i++){
		//cout&lt;&lt;basis_x[index]&lt;&lt;" "&lt;&lt;basis_y[index]&lt;&lt;" "&lt;&lt;basis_z[index]&lt;&lt;endl;
	//}
	
	
	//we now have our basis and we can now generate all S
	int *x_cov = new int[n+1];
	int *y_cov = new int[n+1];
	int *z_cov = new int[n+1];
	for(int i = 0; i &lt;= n; i++){
		x_cov[i] = 0;
		y_cov[i] = 0;
		z_cov[i] = 0;
	}
	generatingS(basis_x,basis_y,basis_z,0,index,x_cov,y_cov,z_cov,0,n);
	
	
	delete [] basis_x;
	delete [] basis_y;
	delete [] basis_z;
	delete [] x_cov;
	delete [] y_cov;
	delete [] z_cov;
} }
</code></pre>
</div>

<p>```</p>

<p>I only had the patience to run up to <code class="highlighter-rouge">n = 17</code>. I observed that there were many sets of max <code class="highlighter-rouge">|S|</code> stored for each <code class="highlighter-rouge">n</code>. Given the way the basis was derived and the recursive function ran, I decided to only filter for the first max <code class="highlighter-rouge">|S|</code> printed for each <code class="highlighter-rouge">n</code>. Here are the first for <code class="highlighter-rouge">n=2</code> to <code class="highlighter-rouge">n=17</code>:</p>

<p>```
n=2:
2
0 0 2
1 1 0
n=3:
3
0 1 2
1 2 0
2 0 1
n=4:
3
0 0 4
1 1 2
2 2 0
n=5:
4
0 0 5
1 2 2
2 3 0
3 1 1</p>

<p>n=6:
5
0 2 4
1 3 2
2 4 0
3 0 3
4 1 1</p>

<p>n=7:
5
0 0 7
1 1 5
2 3 2
3 4 0
4 2 1</p>

<p>n=8:
6
0 0 8
1 3 4
2 4 2
3 5 0
4 1 3
5 2 1</p>

<p>n=9:
7
0 3 6
1 4 4
2 5 2
3 6 0
4 0 5
5 1 3
6 2 1</p>

<p>n=10:
7
0 0 10
1 1 8
2 4 4
3 5 2
4 6 0
5 2 3
6 3 1</p>

<p>n=11:
8
0 0 11
1 4 6
2 5 4
3 6 2
4 7 0
5 1 5
6 2 3
7 3 1</p>

<p>n=12:
9
0 4 8
1 5 6
2 3 7
3 7 2
4 8 0
5 6 1
6 1 5
7 2 3
8 0 4</p>

<p>n=13:
9
0 0 13
1 1 11
2 5 6
3 6 4
4 7 2
5 8 0
6 2 5
7 3 3
8 4 1</p>

<p>n=14:
10
0 0 14
1 5 8
2 6 6
3 4 7
4 8 2
5 9 0
6 7 1
7 2 5
8 3 3
9 1 4</p>

<p>n=15:
11
0 5 10
1 6 8
2 4 9
3 7 5
4 9 2
5 10 0
6 8 1
7 1 7
8 3 4
9 0 6
10 2 3</p>

<p>n=16:
11
0 0 16
1 1 14
2 6 8
3 7 6
4 5 7
5 9 2
6 10 0
7 8 1
8 3 5
9 4 3
10 2 4</p>

<p>n=17:
12
0 0 17
1 6 10
2 7 8
3 5 9
4 8 5
5 10 2
6 11 0
7 9 1
8 2 7
9 4 4
10 1 6
11 3 3
```</p>

<table>
  <tbody>
    <tr>
      <td>This once again does not tell us much other than the fact that there exists a combination with max</td>
      <td>S</td>
      <td>such that the <code class="highlighter-rouge">x</code>’s can be ordered from <code class="highlighter-rouge">0</code> to some sort of limit. Is it guaranteed that for all n the <code class="highlighter-rouge">x</code>’s can be ordered? We will assume for now that the answer is yes. The pattern for the <code class="highlighter-rouge">y</code> and <code class="highlighter-rouge">z</code> are not clear either. I decided to treat <code class="highlighter-rouge">y-z</code> row values as coordinates on a <code class="highlighter-rouge">y-z</code> plane and plot them. Here is a plot for <code class="highlighter-rouge">n=9</code>:</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th>-</th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
      <th>6</th>
      <th>7</th>
      <th>8</th>
      <th>9</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>0</strong></td>
      <td>0</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td>4</td>
      <td><code class="highlighter-rouge">5</code></td>
      <td>6</td>
      <td>7</td>
      <td>8</td>
      <td>9</td>
    </tr>
    <tr>
      <td><strong>1</strong></td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td><code class="highlighter-rouge">4</code></td>
      <td>5</td>
      <td>6</td>
      <td>7</td>
      <td>8</td>
      <td>9</td>
      <td>10</td>
    </tr>
    <tr>
      <td><strong>2</strong></td>
      <td>2</td>
      <td><code class="highlighter-rouge">3</code></td>
      <td>4</td>
      <td>5</td>
      <td>6</td>
      <td>7</td>
      <td>8</td>
      <td>9</td>
      <td>10</td>
      <td>11</td>
    </tr>
    <tr>
      <td><strong>3</strong></td>
      <td>3</td>
      <td>4</td>
      <td>5</td>
      <td>6</td>
      <td>7</td>
      <td>8</td>
      <td><code class="highlighter-rouge">9</code></td>
      <td>10</td>
      <td>11</td>
      <td>12</td>
    </tr>
    <tr>
      <td><strong>4</strong></td>
      <td>4</td>
      <td>5</td>
      <td>6</td>
      <td>7</td>
      <td><code class="highlighter-rouge">8</code></td>
      <td>9</td>
      <td>10</td>
      <td>11</td>
      <td>12</td>
      <td>13</td>
    </tr>
    <tr>
      <td><strong>5</strong></td>
      <td>5</td>
      <td>6</td>
      <td><code class="highlighter-rouge">7</code></td>
      <td>8</td>
      <td>9</td>
      <td>10</td>
      <td>11</td>
      <td>12</td>
      <td>13</td>
      <td>14</td>
    </tr>
    <tr>
      <td><strong>6</strong></td>
      <td><code class="highlighter-rouge">6</code></td>
      <td>7</td>
      <td>8</td>
      <td>9</td>
      <td>10</td>
      <td>11</td>
      <td>12</td>
      <td>13</td>
      <td>14</td>
      <td>15</td>
    </tr>
    <tr>
      <td><strong>7</strong></td>
      <td>7</td>
      <td>8</td>
      <td>9</td>
      <td>10</td>
      <td>11</td>
      <td>12</td>
      <td>13</td>
      <td>14</td>
      <td>15</td>
      <td>16</td>
    </tr>
    <tr>
      <td><strong>8</strong></td>
      <td>8</td>
      <td>9</td>
      <td>10</td>
      <td>11</td>
      <td>12</td>
      <td>13</td>
      <td>14</td>
      <td>15</td>
      <td>16</td>
      <td>17</td>
    </tr>
    <tr>
      <td><strong>9</strong></td>
      <td>9</td>
      <td>10</td>
      <td>11</td>
      <td>12</td>
      <td>13</td>
      <td>14</td>
      <td>15</td>
      <td>16</td>
      <td>17</td>
      <td>18</td>
    </tr>
  </tbody>
</table>

<p>The rows and column labels represent different potential values for <code class="highlighter-rouge">y</code> and <code class="highlighter-rouge">z</code> (first col is <code class="highlighter-rouge">y</code> values and first row is <code class="highlighter-rouge">z</code> values), the entries on <code class="highlighter-rouge">(y,z)</code> coordinates is the sum: <code class="highlighter-rouge">y+z</code>. This is done because as the <code class="highlighter-rouge">x</code> column values increase one by one then, by definition, the sum of the <code class="highlighter-rouge">y</code> and <code class="highlighter-rouge">z</code> entry must decrease by one. This can be observed visually on the graph as each highlighted number is unique. In addition, we know that all numbers in the <code class="highlighter-rouge">x</code> column are unique and therefore the values in the <code class="highlighter-rouge">y</code> and <code class="highlighter-rouge">z</code> columns must also be unique. Graphically, this translates to no row or column having more than one circled number and the equal sum present in each (anti) diagonal corresponds to a specific x value since <code class="highlighter-rouge">x+y+z=n</code>.</p>

<p>We thus have translated our problem to a different, more visual one. Our translation is somewhat similar to the <a href="https://en.wikipedia.org/wiki/Eight_queens_puzzle">Eight(N) queens puzzle</a>: no highlighted-number/queen can appear in the same column/row/(antidiagonal) on the matrix/chessboard with no pieces below the main <code class="highlighter-rouge">y+z=n</code> diagonal. This translation gives us more insight into the restrictions on the values in the triplets and really drives the point home that this problem is only in terms of <code class="highlighter-rouge">y</code> and <code class="highlighter-rouge">z</code>.</p>

<p>If we go back and plot from <code class="highlighter-rouge">n=2</code> to <code class="highlighter-rouge">n=18</code> then one notices there is no pattern amongst the different <code class="highlighter-rouge">n</code>’s and no natural way to build up the solution. This is slightly disappointing because the printed <code class="highlighter-rouge">n=</code> results were the first from max <code class="highlighter-rouge">|S|</code> found in the brute force code. The hope is that by recording the first result, we would have had caught some sort of relation between the different <code class="highlighter-rouge">n</code>.</p>

<p>Nonetheless, we know what the <code class="highlighter-rouge">|S|</code> size is and have a very simple visual way of coming up with new potential solutions. The simple solution for all <code class="highlighter-rouge">n</code> followed the <code class="highlighter-rouge">n=9</code> pattern (after playing around a bit with the different ‘n-chessboard’ it becomes clear). There are two diagonal like lines. Bottom one starts (bottom-left) at some number (for <code class="highlighter-rouge">n=9</code> it is <code class="highlighter-rouge">(y,z)=(6,0)</code>) and the consecutive entries in diagonal like line are located at <code class="highlighter-rouge">(y-1, z+2)</code> all the way up until <code class="highlighter-rouge">y+z=n</code>. The top diagonal like line starts with <code class="highlighter-rouge">y'=y-1</code> from previous <code class="highlighter-rouge">y</code> when <code class="highlighter-rouge">y+z=n</code>. The first(left-bottom most) <code class="highlighter-rouge">z</code> for top diagonal is <code class="highlighter-rouge">z=1</code>. Top diagonal increases in same fashion as bottom one until bounds of ‘chessboard’ are hit.</p>

<p>Our solution now does not depend on <code class="highlighter-rouge">y</code> and <code class="highlighter-rouge">z</code> but on the left most number of the bottom row. If you plot out the ‘chessboards’ for first 10 <code class="highlighter-rouge">n</code>, then when will notice that the pattern is <code class="highlighter-rouge">mod 3</code> and thus the <code class="highlighter-rouge">O(n)</code> solution is formed:</p>

<p>```
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;</algorithm></iostream></vector></cstdio></cmath></p>

<p>int main() {
    int n;cin»n;</p>

<div class="highlighter-rouge"><pre class="highlight"><code>int pairCount = 0;
vector &lt;int&gt; x_y_zPairsOrdered;
int y=0,z=0,x=0;
if(n%3==0){
    y=(2*n)/3 ; 
}
else if(n%3==1){
    y=(2*n - 2) /3 ;
}
else{//n%3==2
    y=( 2*n-1 )/3;
}

//bottom diagonal from left to right
do{
    x=n-y-z;
    x_y_zPairsOrdered.push_back(x);
    x_y_zPairsOrdered.push_back(y);
    x_y_zPairsOrdered.push_back(z);
    y-=1;
    z+=2;
    pairCount++;
}while(y+z &lt;= n);

//upper diagonal from left to right
z=-1;
for(;y &gt;= 0;y--){
    z+=2;
    x=n-z-y;
    pairCount++;
    x_y_zPairsOrdered.push_back(x);
    x_y_zPairsOrdered.push_back(y);
    x_y_zPairsOrdered.push_back(z);
}


//output:
cout&lt;&lt;pairCount&lt;&lt;endl;
for(int i = 0; i &lt; pairCount; i++){
    cout&lt;&lt;x_y_zPairsOrdered[i*3]&lt;&lt;" ";
    cout&lt;&lt;x_y_zPairsOrdered[i*3+1]&lt;&lt;" ";
    cout&lt;&lt;x_y_zPairsOrdered[i*3+2]&lt;&lt;" ";
    cout&lt;&lt;endl;
}
</code></pre>
</div>

<p>}</p>

<p>```</p>

<h3 id="conclusion">Conclusion</h3>

<p>The main idea I wanted to push in this article is that in order to solve complex problems such as the ones present in hackerrank, it is OK to take a two step approach and brute it on your machine first. It is OK to try a stupid solution first. It is all about discovery.</p>

<p>Sometimes it is sufficient to simply work through some examples by hand to notice a pattern when solving these problems. However, sometimes that can be difficult to do and verify correctness of and a two step solution can help crack the problem.</p>

<p>Unfortunately, this tip is not the silver/magic bullet to solving ‘Hard’ problems on hackerrank. Oftentimes, the input to the problem is hard to formulate to begin with (like some graph with complex properties). In our case, we were just given a number n, which is easy to generate as input and easy to generate potential output for and test for correctness. Nonetheless, this approach gave me the opportunity to solve the problem by myself and learn something new during the process. That is always welcome.</p>


  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

	<div class="wrapper">

	 <p style="color:grey">Welcome to my site. Take a look around and don't be shy, shoot me a message!</p>
	</div>
  <div class="wrapper">

    <!--<h2 class="footer-heading">Stan Zonov</h2>-->

    <!--<div class="footer-col-wrapper">
      <div class="footer-col  footer-col-2">
        <ul class="contact-list">
          <!--<li>Stan Zonov</li>-->
          <!--<li>contact at zonov.ca</li>
        </ul>
      </div>-->

      <div class="footer-col  footer-col-1">
        <ul class="social-media-list">
									<li>
            <p>

<span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
																	<g transform="scale(0.035)">
                  <path fill="#828282" d="M101.3 141.6v228.9h0.3 308.4 0.8V141.6H101.3zM375.7 167.8l-119.7 91.5 -119.6-91.5H375.7zM127.6 194.1l64.1 49.1 -64.1 64.1V194.1zM127.8 344.2l84.9-84.9 43.2 33.1 43-32.9 84.7 84.7L127.8 344.2 127.8 344.2zM384.4 307.8l-64.4-64.4 64.4-49.3V307.8z"/>
																</g>
                </svg>
              </span>

              <span class="username">contact at zonov.ca</span>
            </p>
          </li>


          

          


          


        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text"></p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
