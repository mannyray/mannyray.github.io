<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>KalmanFilter: Kalman Filter</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">KalmanFilter
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Kalman Filter </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is a <code>C++</code> Kalman filter library designed to work with various data types and provide flexibility to use more advanced models. The <code>C++</code> language may seem verbose to those transitioning from say <code>Python</code> or <code>Matlab</code>. However, this library may seem verbose not only to the <code>Python</code> user but to the <code>C++</code> user as well. To address this concern, many examples, good documentation and motivation behind the code will be discussed. This is an active project and will continue to grow. I am planning to add additional filters such as the UKF and add further examples. I am looking for help in optimizing the code further as well as adding additional filters and features - if you have ideas, advice or bugs then let me know.</p>
<p>If you are new to Kalman filters then please check out rlabbe's <a href="https://github.com/rlabbe/Kalman-and-Bayesian-Filters-in-Python">github repository</a> to get an intuition behind the Kalman filter. I assume if you are reading past this point, you have a basic understanding of the Kalman filter, what it requires and common notation used.</p>
<p>First thing let's install the code. The code has been tested on Ubuntu system for now.</p>
<div class="fragment"><div class="line">$ git clone https://github.com/mannyray/KalmanFilter.git</div><div class="line">$ cd KalmanFilter/c++_implementation</div><div class="line">$ chmod u+x install.sh</div><div class="line">$ ./install.sh</div></div><!-- fragment --><p>The install script only modifies <code><a class="el" href="Eigen_8h_source.html">include/Eigen.h</a></code>. This library is a header-only library.</p>
<p>We will be looking at <code>examples/basicExample.cpp</code> and <code>examples/sampleModel.h</code> in the following tutorial to understand the library. The Kalman filter can be described by the following image (page 147) from <code>Introduction to Random Signals and Applied Kalman Filtering with Matlab Exercises</code> by <code>Robert Grover Brown</code> and <code>Patrick Y. C. Hwang</code>:</p>
<div class="image">
<img src="filter1.png" alt="filter1.png"/>
</div>
<p>To run this we need a few ingredients. Using the notation from the image, first we need the <em>transition equation</em> for the 'Project ahead' block:</p>
<p><img class="formulaInl" alt="$ \hat{x}_{k+1}^- = \phi_k \hat{x}_{k} $" src="form_0.png"/> .</p>
<p>In addition, from the 'Project ahead' we need the <em>transition Jacobian</em> <img class="formulaInl" alt="$ \bf{\Phi}_k $" src="form_1.png"/> and <em>process noise</em> <img class="formulaInl" alt="$ \bf{Q}_k $" src="form_2.png"/>. We need a <em>measurement equation</em> that is not included in the diagram here:</p>
<p><img class="formulaInl" alt="$ z_k = C(x_k) $" src="form_3.png"/> .</p>
<p>Finally, we need the <em>measurement Jacobian</em> <img class="formulaInl" alt="$ H_k $" src="form_4.png"/> and sensor noise <img class="formulaInl" alt="$R_k$" src="form_5.png"/>. Let's consider a specific system:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \ddot{x} + \sqrt{2}w_0\dot{x} + w_0^2x = b\sigma u \]" src="form_6.png"/>
</p>
<p>This ODE describes a damped harmonic oscillator at position <img class="formulaInl" alt="$ x $" src="form_7.png"/> with a forcing white noise term on the right hand side. The equation is taken from <code>Introduction to Random Signals and Applied Kalman Filtering with Matlab Exercises</code> section 4.4 <code>Robert Grover Brown</code> and <code>Patrick Y. C. Hwang</code> book mentioned earlier. The model can be expressed as follows </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{d}{dt}\begin{bmatrix}x_1 \\ x_2\end{bmatrix} = \begin{bmatrix} 0 &amp; 1\\ -w_0^2 &amp; -\sqrt{2}w_0 \end{bmatrix} \begin{bmatrix} x_1 \\ x_2 \end{bmatrix} \]" src="form_8.png"/>
</p>
<p> where <img class="formulaInl" alt="$x_1 = x $" src="form_9.png"/> and <img class="formulaInl" alt="$ x_2 = \dot{x} $" src="form_10.png"/>. Using the Van Loan method described in section 3.9 of the afformentioned source the model can be discretized assuming <img class="formulaInl" alt="$ \Delta t = 1$" src="form_11.png"/> using the following Octave script:</p>
<div class="fragment"><div class="line">pkg load symbolic</div><div class="line">syms w_0 </div><div class="line">syms b % b = sqrt(2 * sqrt(2) w_0^3)</div><div class="line">syms sig</div><div class="line">syms delta_t</div><div class="line">F = [sym(0),1;-w_0*w_0, -sym(14142135623731)/10000000000000*w_0];</div><div class="line">G = [0;b*sig];</div><div class="line">A = delta_t*[-F,G*G&#39;;[0,0;0,0],F&#39;];</div><div class="line">B = expm(A);</div><div class="line">delta_t_val = sym(1)/1;</div><div class="line">w_0_val = sym(1)/10;%use whatever values you want </div><div class="line">b_val = sym(1000000000000)/18803015465432;%octave requires such measures to reduces numerical errors</div><div class="line">sig_val = sym(1)/1;</div><div class="line">B_sub = eval(subs(subs(subs(subs(B,b,b_val),w_0,w_0_val),sig,sig_val),delta_t,delta_t_val));</div><div class="line">transitionMatrix = B_sub(3:4,3:4)<span class="stringliteral">&#39;;</span></div><div class="line"><span class="stringliteral">processNoise = real(transitionMatrix*B_sub(1:2,3:4));</span></div></div><!-- fragment --><p>to produce</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \begin{bmatrix} X_1 \\ X_2 \end{bmatrix}_{k+1} = \begin{bmatrix} 0.9952315 &amp; 0.9309552 \\ -0.0093096 &amp; 0.8635746 \end{bmatrix} \begin{bmatrix}X_1 \\ X_2 \end{bmatrix}_k \]" src="form_12.png"/>
</p>
<p>where <img class="formulaInl" alt="$(X_1)_k \approx x_1(t = k) $" src="form_13.png"/> and <img class="formulaInl" alt="$(X_2)_k \approx x_2(t = k) $" src="form_14.png"/> with process noise</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \bf{Q}_k = \begin{bmatrix} 8.4741e-04 &amp; 1.2257e-03 \\ 1.2257e-03 &amp; 2.4557e-03 \end{bmatrix}. \]" src="form_15.png"/>
</p>
<p> We will select to measure <img class="formulaInl" alt="$X_1$" src="form_16.png"/> only so our measurement equation will be </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ z_k = \begin{bmatrix}1 &amp; 0 \end{bmatrix} \begin{bmatrix}X_1 \\ X_2 \end{bmatrix}. \]" src="form_17.png"/>
</p>
<p> The sensor noise will be </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ R_k = (0.5)^2 = 0.25. \]" src="form_18.png"/>
</p>
<p> The transition jacobian will naturally be </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \begin{bmatrix} 0.9952315 &amp; 0.9309552 \\ -0.0093096 &amp; 0.8635746 \end{bmatrix} \]" src="form_19.png"/>
</p>
<p> with measurement jacobian </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \begin{bmatrix}1 &amp; 0 \end{bmatrix}. \]" src="form_20.png"/>
</p>
<p>By now you are familiar with what the Kalman filter needs:</p><ul>
<li>transition equation</li>
<li>measurement equation</li>
<li>process noise covariance</li>
<li>sensor noise covariance</li>
<li>transition jacobian</li>
<li>measurement jacobian</li>
</ul>
<p>Let's implement the ingredients for our specific example. In this case we will use the <a href="http://eigen.tuxfamily.org/index.php?title=Main_Page"><code>Eigen</code></a> library.</p>
<h3>Transition equation</h3>
<p>All ingredients or components of a system will inherit from general ingredient or component classes. In this example, we will call the class <code>stateModel</code> and it will inherit from template class <code><a class="el" href="classdiscreteModel.html">discreteModel</a></code> of <code>Eigen::VectorXd</code> type since we are working with the <code>Eigen</code> library. The general class <code><a class="el" href="classdiscreteModel.html">discreteModel</a></code> is presented first:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class </span><a class="code" href="classdiscreteModel.html">discreteModel</a>: <span class="keyword">public</span> <a class="code" href="classmodel.html">model</a>&lt;int&gt;{</div><div class="line">        <span class="keyword">public</span>:</div><div class="line">                <span class="keyword">virtual</span> T <span class="keyword">function</span>(<span class="keyword">const</span> T&amp; val, <span class="keyword">const</span> <span class="keywordtype">int</span> index) <span class="keyword">const</span> = 0;</div><div class="line">};</div></div><!-- fragment --><p> <code><a class="el" href="classdiscreteModel.html">discreteModel</a></code> is abstract and any class that inherits from it needs to implement the <code>function</code> method. We can use this class to easily implement (1):</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>stateModel: <span class="keyword">public</span> <a class="code" href="classdiscreteModel.html">discreteModel</a>&lt;Eigen::VectorXd&gt;{</div><div class="line">    Eigen::MatrixXd v;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        stateModel(){</div><div class="line">            Eigen::MatrixXd tmp(2,2);</div><div class="line">            tmp&lt;&lt;0.995231,0.9309552,-0.0093096,0.8635746;</div><div class="line">            v = tmp;</div><div class="line">        }</div><div class="line">        Eigen::VectorXd <span class="keyword">function</span>(<span class="keyword">const</span> Eigen::VectorXd &amp; val, <span class="keyword">const</span> <span class="keywordtype">int</span> time) <span class="keyword">const</span> <span class="keyword">override</span>{</div><div class="line">            <span class="keywordflow">return</span> v*val;</div><div class="line">        }</div><div class="line">};</div></div><!-- fragment --><p><code>stateModel</code> implements <code>function</code> of <code><a class="el" href="classdiscreteModel.html">discreteModel</a></code> but now has an extra member and even a constructor. This is where the flexibility to the user comes into play. If you want to pass parameters to your constructor in order to have different and multiple instances of a model then you are free to do so. Why have multiple instances? Maybe you are working on tuning your filter or are experimenting with assuming various models. No matter the reason, this library gives you the opportunity to do so easily.</p>
<p><code>function</code> in this case implements the important relationship of (1). The first argument of <code>function</code> within the Kalman filter will be the previous estimate of the model while <code>time</code> is the current model time which allows for an implementation of a time based model.</p>
<h3>Measurement equation</h3>
<p>In this instance we implement (2). We will call the class <code>measurementModel</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>measurementModel: <span class="keyword">public</span> <a class="code" href="classdiscreteModel.html">discreteModel</a>&lt;Eigen::VectorXd&gt;{</div><div class="line">    Eigen::MatrixXd v;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        measurementModel(){</div><div class="line">            Eigen::MatrixXd tmp(1,2);tmp&lt;&lt;1.0,0.0;</div><div class="line">            v = tmp;</div><div class="line">        }</div><div class="line">        Eigen::VectorXd <span class="keyword">function</span>(<span class="keyword">const</span> Eigen::VectorXd &amp; val, <span class="keyword">const</span> <span class="keywordtype">int</span> time) <span class="keyword">const</span> <span class="keyword">override</span>{</div><div class="line">            <span class="keywordflow">return</span> v*val;</div><div class="line">        }</div><div class="line">};</div></div><!-- fragment --><p><code>measurementModel</code> inherits from the same <code><a class="el" href="classdiscreteModel.html">discreteModel</a></code> class as did <code>stateModel</code> of the transition equation.</p>
<h3>Process Noise</h3>
<p><code><a class="el" href="classdiscreteModel.html">discreteModel</a></code> was used for (1) and (2). Similarly for both sensor and process noise the following base class will be used:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> VECTOR, <span class="keyword">class</span> MATRIX&gt;</div><div class="line"><span class="keyword">class </span><a class="code" href="classdiscreteNoiseCovariance.html">discreteNoiseCovariance</a>: <span class="keyword">public</span> <a class="code" href="classnoiseCovariance.html">noiseCovariance</a>&lt;VECTOR,MATRIX,int&gt;{</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">virtual</span> MATRIX <span class="keyword">function</span>(<span class="keyword">const</span> VECTOR &amp; val, <span class="keywordtype">int</span> t) = 0; </div><div class="line">        <span class="keyword">virtual</span> MATRIX sqrt(<span class="keyword">const</span> VECTOR &amp; val, <span class="keywordtype">int</span> t) = 0;</div><div class="line">};</div></div><!-- fragment --><p>The two pure virtual methods are <code>function</code> and <code>sqrt</code>. <code>function</code> returns the covariance matrix at time <code>t</code> while - the <code>VECTOR</code> input is available for use in case the covariance depends on the state/estimate of the system - such as in distance based applications. The second method is <code>sqrt</code> which will return the Cholesky decomposition (specify which one - upper or lower) which is used for sampling noises in <code><a class="el" href="classdiscreteDiscreteFilterSolver.html">discreteDiscreteFilterSolver</a></code> (see <a href="https://en.wikipedia.org/wiki/Multivariate_normal_distribution#Drawing_values_from_the_distribution">here</a> for details) and is used in the square root filter.</p>
<p>The process noise (3) is implemented in class <code>processNoise</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>processNoise: <span class="keyword">public</span> <a class="code" href="classdiscreteNoiseCovariance.html">discreteNoiseCovariance</a>&lt;Eigen::VectorXd,Eigen::MatrixXd&gt;{</div><div class="line">    Eigen::MatrixXd v;</div><div class="line">    Eigen::MatrixXd sqrtMat;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        processNoise(){</div><div class="line">            Eigen::MatrixXd tmp(2,2);</div><div class="line">            tmp&lt;&lt;8.4741e-04,1.2257e-03,1.2257e-03,2.4557e-03; </div><div class="line">            v = tmp;</div><div class="line">            Eigen::LLT&lt;Eigen::MatrixXd&gt; lltOfV(v);</div><div class="line">            sqrtMat = lltOfV.matrixL();</div><div class="line">        }</div><div class="line">        Eigen::MatrixXd <span class="keyword">function</span>(<span class="keyword">const</span> Eigen::VectorXd &amp;est, <span class="keywordtype">int</span> t) <span class="keyword">override</span>{</div><div class="line">            <span class="keywordflow">return</span> v;</div><div class="line">        }</div><div class="line">        Eigen::MatrixXd sqrt(<span class="keyword">const</span> Eigen::VectorXd &amp;est, <span class="keywordtype">int</span> t)<span class="keyword"> override</span>{</div><div class="line">            <span class="keywordflow">return</span>  sqrtMat; </div><div class="line">        }</div><div class="line">};</div></div><!-- fragment --><p>In these cases the methods are simple and return an already precomputed result without making use of the arguments as the system is simple. Despite the simplicity, it is the <em>user's responsibility</em> to make sure the dimensions of various matrices, vectors that are returned or used in the various 'ingredients' of the system are logically correct and consistent.</p>
<h3>Sensor Noise</h3>
<div class="fragment"><div class="line"><span class="keyword">class </span>sensorNoise: <span class="keyword">public</span> <a class="code" href="classdiscreteNoiseCovariance.html">discreteNoiseCovariance</a>&lt;Eigen::VectorXd,Eigen::MatrixXd&gt;{</div><div class="line">    Eigen::MatrixXd v;</div><div class="line">    Eigen::MatrixXd sqrtMat;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        sensorNoise(){</div><div class="line">            Eigen::MatrixXd tmp(1,1);</div><div class="line">            tmp&lt;&lt;0.25;</div><div class="line">            v = tmp;</div><div class="line">            Eigen::MatrixXd tmp2(1,1);</div><div class="line">            tmp2&lt;&lt;0.5;</div><div class="line">            sqrtMat = tmp2; </div><div class="line">        }</div><div class="line">        Eigen::MatrixXd <span class="keyword">function</span>(<span class="keyword">const</span> Eigen::VectorXd &amp;est, <span class="keywordtype">int</span> t) <span class="keyword">override</span>{</div><div class="line">            <span class="keywordflow">return</span> v;</div><div class="line">        }</div><div class="line">        Eigen::MatrixXd sqrt(<span class="keyword">const</span> Eigen::VectorXd &amp;est, <span class="keywordtype">int</span> t)<span class="keyword"> override</span>{</div><div class="line">            <span class="keywordflow">return</span> sqrtMat; </div><div class="line">        }</div><div class="line">};</div></div><!-- fragment --><p>### Transition Jacobian </p><div class="fragment"><div class="line"><span class="keyword">class </span>transitionJac: <span class="keyword">public</span> <a class="code" href="classjacobianDiscrete.html">jacobianDiscrete</a>&lt;Eigen::VectorXd,Eigen::MatrixXd&gt;{</div><div class="line">    Eigen::MatrixXd v;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        transitionJac(){</div><div class="line">            Eigen::MatrixXd tmp(2,2);</div><div class="line">            tmp&lt;&lt;0.995231,0.9309552,-0.0093096,0.8635746;</div><div class="line">            v = tmp;</div><div class="line">        }</div><div class="line"></div><div class="line">        Eigen::MatrixXd <span class="keyword">function</span>(<span class="keyword">const</span> Eigen::VectorXd &amp; val, <span class="keywordtype">int</span> t){</div><div class="line">            <span class="keywordflow">return</span> v;</div><div class="line">        }</div><div class="line">};</div></div><!-- fragment --><h3>Measurement Jacobian</h3>
<div class="fragment"><div class="line"><span class="keyword">class </span>measurementJac: <span class="keyword">public</span> <a class="code" href="classjacobianDiscrete.html">jacobianDiscrete</a>&lt;Eigen::VectorXd,Eigen::MatrixXd&gt;{</div><div class="line">    Eigen::MatrixXd v;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        measurementJac(){</div><div class="line">            Eigen::MatrixXd tmp(1,2);</div><div class="line">            tmp&lt;&lt;1.0,0.0;</div><div class="line">            v = tmp;</div><div class="line">        }</div><div class="line"></div><div class="line">        Eigen::MatrixXd <span class="keyword">function</span>(<span class="keyword">const</span> Eigen::VectorXd &amp; val, <span class="keywordtype">int</span> t){</div><div class="line">            <span class="keywordflow">return</span> v;</div><div class="line">        }</div><div class="line">};</div></div><!-- fragment --><h2>Putting it all together</h2>
<p>Since we have all the ingredients (in <code>examples/sampleModel.h</code>), we are ready to combine them together to define the model. First create instances of the previously discussed classes:</p>
<div class="fragment"><div class="line">stateModel tm;</div><div class="line">measurementModel mm;</div><div class="line">processNoise pn;</div><div class="line">sensorNoise sn;</div><div class="line">transitionJacobian tj;</div><div class="line">measurementJacobian mj;</div></div><!-- fragment --><p> Then specify the state count and sensor count for this specific model</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> stateCount = 2;</div><div class="line"><span class="keywordtype">int</span> sensorCount = 1;</div></div><!-- fragment --><p>Now we create an instance of the model.</p>
<div class="fragment"><div class="line"><a class="code" href="classdiscreteDiscreteFilterModel.html">discreteDiscreteFilterModel&lt;Eigen::VectorXd,Eigen::MatrixXd&gt;</a> ddfm(&amp;tm,&amp;mm,&amp;pn,&amp;sn,&amp;tj,&amp;mj,stateCount,sensorCount);</div></div><!-- fragment --><p><code><a class="el" href="classdiscreteDiscreteFilterModel.html">discreteDiscreteFilterModel</a></code>'s purpose is to provide a nice collection of the ingredients in one class while providing an interface layer of the ingredient's methods to other classes. The interface layer allows for easier refactoring of the underlying ingredients.</p>
<p>As probably guessed by the reader, the parameters of <code><a class="el" href="classdiscreteDiscreteFilterModel.html">discreteDiscreteFilterModel</a></code>'s constructor are pointers to abstract types such as <code><a class="el" href="classdiscreteModel.html">discreteModel</a></code> which makes the code easy to use for various models/jacobians/noises. The <code>&lt;Eigen::VectorXd,Eigen::MatrixXd&gt;</code> specifies which vector and matrix type is used in the code as the majority of the code is built on templates - read the documentation to make sure the types and function parameters entered are in correct order.</p>
<p>Two classes that depend on the <code><a class="el" href="classdiscreteDiscreteFilterModel.html">discreteDiscreteFilterModel</a></code> are <code><a class="el" href="classdiscreteDiscreteFilterSolver.html">discreteDiscreteFilterSolver</a></code> and the filter itself: <code><a class="el" href="classdiscreteDiscreteKalmanFilter.html">discreteDiscreteKalmanFilter</a></code>. <code><a class="el" href="classdiscreteDiscreteFilterSolver.html">discreteDiscreteFilterSolver</a></code> is used in cases when one does not have any sample data/measurements and needs to generate them as is common when running simulations. Let's generate some data for our specific model. We need to specify an initial condition and initial time for the system as well:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> initialTime = 0;</div><div class="line">Eigen::VectorXd initialState(2);</div><div class="line">initialState&lt;&lt;0,0;</div><div class="line"><a class="code" href="classdiscreteDiscreteFilterSolver.html">discreteDiscreteFilterSolver&lt;Eigen::VectorXd,Eigen::MatrixXd&gt;</a> ddfs(&amp;ddfm,initialTime,initialState);</div></div><!-- fragment --><p> Let's say we want to solve for <code>10000</code> time steps: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> steps = 10000;</div><div class="line">ddfs.solve(steps);</div></div><!-- fragment --><p> To get generated measurements and the true state of the system run: </p><div class="fragment"><div class="line">Eigen::VectorXd * states = ddfs.getSolvedStates();</div><div class="line">Eigen::VectorXd * measurements = ddfs.getSolvedMeasurements()</div></div><!-- fragment --><p>We now have almost everything. Before running the Kalman filter we need to define our initial estimate and initial covariance: </p><div class="fragment"><div class="line">Eigen::VectorXd initiaEstimate(2);</div><div class="line">initialEstimate&lt;&lt;0,0;</div><div class="line">Eigen::MatrixXd initialCovariance(2,2);</div><div class="line">initialCovariance&lt;&lt;1,0,0,0.01;</div></div><!-- fragment --><p> In our idealized case here the <code>initialEstimate</code> and <code>initialState</code> match up exactly.</p>
<p>If you have read the afformentioned rlabbe repository or studied the Kalman filter previously you will know that the filter consists of the <code>predict</code> and <code>update</code> phase that are repeated for all the measurements over and over again. Hence to filter through the measurements, we run:</p>
<div class="fragment"><div class="line"><a class="code" href="classdiscreteDiscreteKalmanFilter.html">discreteDiscreteKalmanFilter&lt;Eigen::VectorXd,Eigen::MatrixXd&gt;</a> filter(initialTime, initialEstimate, initialCovariance,&amp;ddfm);</div><div class="line"></div><div class="line">Eigen::VectorXd * estimates = <span class="keyword">new</span> Eigen::VectorXd[steps];</div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; steps; i++){</div><div class="line">    filter.predict(1);</div><div class="line">    filter.update(measurements[i]);</div><div class="line"></div><div class="line">    estimates[i] = filter.getCurrentEstimate();</div><div class="line">    <span class="comment">//save the estimate or save the covariance, save only every 10th estimate,do nothing,</span></div><div class="line">    <span class="comment">//just run predict if you&#39;re simulating infrequent measurements..it&#39;s up to you and your context</span></div><div class="line">}</div></div><!-- fragment --><p>We have finally filtered the data and the estimates are stored in <code>estimates</code> array. The user may be wondering why put the burden of running the predict and update on the user and not the Kalman Filter class. Why not simply pass in the <code>measurements</code> array into some method? First of all, if you have gotten all the way here after reviewing the ingridients and are upset with a simple for loop then shame on you. Second of all, the context in which the Kalman filter can be used is diverse. Users may have different output requirements. In addition, passing in a measurement array implies post processing of data and does not allow for 'real time' processing and logic such as adding system input. Finally, it gets the user used to the update/predict terminogy as is common with the Kalman filter and lets them avoid off-by-one logic errors.</p>
<p>Run <code>cd examples; g++ basixExample.cpp; ./a.out</code> to save the data into <code>estimates.txt</code>, <code>states.txt</code>, <code>measurements.txt</code>. We can plot the results using Octave: </p><div class="fragment"><div class="line">dd = load(<span class="stringliteral">&#39;estimates.txt&#39;</span>);</div><div class="line">estimates = [dd(1:2:end)&#39;;dd(2:2:end)&#39;];</div><div class="line">dd = load(<span class="stringliteral">&#39;states.txt&#39;</span>);</div><div class="line">states = [dd(1:2:end)&#39;;dd(2:2:end)&#39;];</div><div class="line">dd = load(<span class="stringliteral">&#39;measurements.txt&#39;</span>);</div><div class="line">measurements = dd<span class="stringliteral">&#39;;</span></div><div class="line"><span class="stringliteral">limits = 200;</span></div><div class="line"><span class="stringliteral">hold on</span></div><div class="line"><span class="stringliteral">plot(1:limits,measurements(1:limits),&#39;</span>r<span class="charliteral">&#39;,&#39;</span>linewidth<span class="stringliteral">&#39;,1);</span></div><div class="line"><span class="stringliteral">plot(1:limits,estimates(1,1:limits),&#39;</span>b<span class="charliteral">&#39;,&#39;</span>linewidth<span class="stringliteral">&#39;,2);</span></div><div class="line"><span class="stringliteral">plot(1:limits,states(1,1:limits),&#39;</span>g<span class="charliteral">&#39;,&#39;</span>linewidth<span class="stringliteral">&#39;,2);</span></div><div class="line"><span class="stringliteral">xlabel (&quot;Time&quot;);</span></div><div class="line"><span class="stringliteral">ylabel (&quot;Position&quot;);</span></div><div class="line"><span class="stringliteral">legend(&quot;Measurement&quot;,&quot;Estimate&quot;,&quot;True State&quot;);</span></div></div><!-- fragment --><p> to obtain</p>
<div class="image">
<img src="filter2.png" alt="drawing" width="80%"/>
</div>
<p>Let's compare the results to the matlab implementation </p><div class="fragment"><div class="line">addpath(<span class="stringliteral">&#39;../../../KalmanFilter/matlab_implementation/discrete_discrete/&#39;</span>)</div><div class="line">next_func = @(x,t) transitionMatrix*x;</div><div class="line">jacobian_func = @(x,t) transitionMatrix;</div><div class="line">dt = 1;</div><div class="line">t_start = 0;</div><div class="line">state_count = 2;</div><div class="line">sensor_count = 1;</div><div class="line">outputs = 10000;</div><div class="line">C = [1 0];</div><div class="line">Q_d = processNoise;</div><div class="line">R_d = 0.25;</div><div class="line">P_0 = [1,0;0,0.01];</div><div class="line">x_0 = [0;0];</div><div class="line"></div><div class="line">[estimatesOctave, covariancesOctave ] = ddekf(next_func,jacobian_func,dt,t_start,state_count,...</div><div class="line">    sensor_count,outputs,C,chol(Q_d)&#39;,chol(R_d)&#39;,chol(P_0)&#39;,x_0, measurements);</div></div><!-- fragment --><p>Testing against the matlab square root implementation</p>
<div class="fragment"><div class="line">hold on;</div><div class="line">plot(estimates(1,1:limits),<span class="charliteral">&#39;r&#39;</span>,<span class="stringliteral">&#39;linewidth&#39;</span>,3)</div><div class="line">plot(estimatesOctave(1,2:limits+1),&#39;b&#39;)</div><div class="line">plot(estimates(1,1:limits) - estimatesOctave(1,2:limits+1),&#39;g&#39;)</div><div class="line">xlabel (&quot;Time&quot;);</div><div class="line">ylabel (&quot;Position&quot;);</div><div class="line">legend(&quot;C++ position&quot;,&quot;Matlab square root estimate&quot;,&quot;Difference&quot;)</div><div class="line">max(abs(estimates(1,:) - estimatesOctave(1,2:end)))%max error</div><div class="line">max(abs(estimates(1,:) - estimatesOctave(1,2:end))./estimates(1,:))%max absolute error</div><div class="line">sum(abs(abs(estimates(1,:) - estimatesOctave(1,2:end))./estimates(1,:)))/10000</div></div><!-- fragment --><div class="image">
<img src="filter3.png" alt="drawing2" width="80%"/>
</div>
<p>with a maximum error of <code>1.64246433278281e-04</code> with max relative error of <code>56</code> percent (since they were close to zero estimates with one being <code>1.56686514969348e-04</code> while other<code>1.00210021201516e-04</code>). The average relative error is <code>0.11</code> percent. The test is passed.</p>
<h3>Discussing the templates</h3>
<p>Why use templates? The idea is to allow for the use of various matrix/vector libraries in combination with a Kalman filter library. Two main ones that come to mind are <code>Eigen</code> and <code>Boost</code>. The code tutorial above is in <code>examples/basicExample.cpp</code> for the <code>Eigen</code> library while identical boost copy is located within <code>examples/basicExampleBoost.cpp</code>. After compiling and running, the results are identical:</p>
<div class="fragment"><div class="line">dd = load(<span class="stringliteral">&#39;estimatesBoost.txt&#39;</span>);</div><div class="line">estimatesBoost = [dd(1:2:end)&#39;;dd(2:2:end)&#39;];</div><div class="line">dd = load(<span class="stringliteral">&#39;estimates.txt&#39;</span>);</div><div class="line">estimates = [dd(1:2:end)&#39;;dd(2:2:end)&#39;];</div><div class="line">max(estimates(1,:) - estimatesBoost(1,:))</div></div><!-- fragment --><p>with max difference <code>3.81361608958741e-14</code>.</p>
<p><code>examples/basicExamplesBoost.cpp</code> uses a wrapper class from <code>include/mathWrapper</code> that wraps the <code>boost</code> library. The reason for wrapping is because the template class in <code>include/KalmanFitler.h</code> uses operators for matrices and vectors such as <code>+</code> and <code>*</code> that are defined for <code>Eigen</code> but not <code>boost</code> (see <a href="https://stackoverflow.com/questions/20056774/why-has-ublas-no-operatormatrix-vector">1</a>, <a href="http://boost.2283326.n4.nabble.com/Patch-proposal-for-overloading-operator-in-ublas-td2711622.html">2</a>, <a href="https://valelab4.ucsf.edu/svn/3rdpartypublic/boost/libs/numeric/ublas/doc/overview.htm">3</a>) or potentially other libraries. In fact, the original example <code>examples/basicExample.cpp</code> uses an extension to the <code>Eigen</code> library in <code><a class="el" href="Eigen_8h_source.html">include/Eigen.h</a></code> instead of the regular <code>&lt;Eigen/Dense&gt;</code> since an additional random vector function needed to be added used in <code><a class="el" href="classdiscreteDiscreteFilterSolver.html">discreteDiscreteFilterSolver</a></code>. The wrappers will provide the opportunity for further functionality required to implement square root versions of filters.</p>
<p>Instead of using <code>Eigen</code> or <code>Boost</code> lets use the good old <code>double</code> to introduce a basic one dimensional nonlinear filtering example.</p>
<h3>Nonlinear example:</h3>
<p>A nonlinear example is included <code>examples/basicExampleNonlinear.cpp</code> that uses the <code>double</code> wrapper in <code><a class="el" href="double_8h_source.html">include/mathWrapper/double.h</a></code>. This wrapper allows for simple one dimensional examples without needing to install any extra libraries such as <code>Eigen</code> or <code>Boost</code>. The model used is the discrete logistic population growth.</p>
<div class="fragment"><div class="line">dd = load(<span class="stringliteral">&#39;estimatesNonlin.txt&#39;</span>);</div><div class="line">estimates = dd<span class="stringliteral">&#39;;</span></div><div class="line"><span class="stringliteral">dd = load(&#39;</span>statesNonlin.txt<span class="stringliteral">&#39;);</span></div><div class="line"><span class="stringliteral">states = dd&#39;</span>;</div><div class="line">dd = load(<span class="stringliteral">&#39;measurementsNonlin.txt&#39;</span>);</div><div class="line">measurements = dd<span class="stringliteral">&#39;;</span></div><div class="line"><span class="stringliteral">limits = 100;</span></div><div class="line"><span class="stringliteral">hold on</span></div><div class="line"><span class="stringliteral">plot(1:limits,measurements(1:limits),&#39;</span>r<span class="charliteral">&#39;,&#39;</span>linewidth<span class="stringliteral">&#39;,1);</span></div><div class="line"><span class="stringliteral">plot(1:limits,estimates(1:limits),&#39;</span>b<span class="charliteral">&#39;,&#39;</span>linewidth<span class="stringliteral">&#39;,2);</span></div><div class="line"><span class="stringliteral">plot(1:limits,states(1:limits),&#39;</span>g<span class="charliteral">&#39;,&#39;</span>linewidth<span class="stringliteral">&#39;,2);</span></div><div class="line"><span class="stringliteral">xlabel (&quot;Time&quot;);</span></div><div class="line"><span class="stringliteral">ylabel (&quot;Population&quot;);</span></div><div class="line"><span class="stringliteral">legend(&quot;Measurement&quot;,&quot;Estimate&quot;,&quot;True State&quot;);</span></div></div><!-- fragment --><div class="image">
<img src="filter4.png" alt="drawing2" width="80%"/>
</div>
 </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
